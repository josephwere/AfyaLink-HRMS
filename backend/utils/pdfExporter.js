import PDFDocument from "pdfkit";
import crypto from "crypto";
import { signData } from "./pkiSigner.js";

/* ===== OPTIONAL ADDITIVE IMPORTS (SAFE) ===== */
import EvidenceAnchor from "../models/EvidenceAnchor.js";
import { anchorHash } from "./blockchainAnchor.js";

export const generateCourtPDF = async (title, data, meta = {}) => {
  const doc = new PDFDocument({ margin: 50 });
  const chunks = [];

  doc.on("data", (chunk) => chunks.push(chunk));

  /* =========================
     DOCUMENT HEADER
  ========================= */
  doc.fontSize(18).text(title, { align: "center" });
  doc.moveDown();

  doc.fontSize(10).text(`Generated At: ${new Date().toISOString()}`);
  doc.text(`Hospital ID: ${meta.hospital}`);
  doc.text(`Generated By: ${meta.generatedBy}`);
  doc.moveDown();

  /* =========================
     MAIN CONTENT
  ========================= */
  doc.fontSize(12).text(JSON.stringify(data, null, 2));
  doc.moveDown();

  /* =========================
     HASH + SIGNATURE
  ========================= */
  const hash = crypto
    .createHash("sha256")
    .update(JSON.stringify(data))
    .digest("hex");

  const signature = signData(hash);

  doc.fontSize(10).text(`Evidence Hash (SHA-256): ${hash}`);
  doc.text("This document is digitally signed and tamper-evident.");

  doc.end();

  return new Promise((resolve) => {
    doc.on("end", async () => {
      const buffer = Buffer.concat(chunks);

      /* =========================
         BLOCKCHAIN ANCHOR (NON-BLOCKING)
      ========================= */
      try {
        if (meta?.hospital && meta?.resourceId) {
          const { blockchain, txHash } = await anchorHash(hash);

          await EvidenceAnchor.create({
            hospital: meta.hospital,
            resourceType: "PDF",
            resourceId: meta.resourceId,
            hash,
            signature,
            blockchain,
            txHash,
          });
        }
      } catch (err) {
        // ðŸ”’ Never block PDF generation
        console.error("Blockchain anchoring failed:", err.message);
      }

      resolve({
        buffer,
        hash,
        signature,
      });
    });
  });
};
