import {
  __commonJS
} from "./chunk-PR4QN5HX.js";

// node_modules/uuid/lib/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/uuid/lib/rng-browser.js"(exports, module) {
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      rnds8 = new Uint8Array(16);
      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      rnds = new Array(16);
      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0) r = Math.random() * 4294967296;
          rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds8;
    var rnds;
  }
});

// node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/uuid/lib/bytesToUuid.js"(exports, module) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module.exports = bytesToUuid;
  }
});

// node_modules/uuid/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/v1.js"(exports, module) {
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module.exports = v1;
  }
});

// node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/v4.js"(exports, module) {
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module.exports = v4;
  }
});

// node_modules/uuid/index.js
var require_uuid = __commonJS({
  "node_modules/uuid/index.js"(exports, module) {
    var v1 = require_v1();
    var v4 = require_v4();
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    module.exports = uuid;
  }
});

// node_modules/automerge/src/uuid.js
var require_uuid2 = __commonJS({
  "node_modules/automerge/src/uuid.js"(exports, module) {
    var { v4: uuid } = require_uuid();
    function defaultFactory() {
      return uuid().replace(/-/g, "");
    }
    var factory = defaultFactory;
    function makeUuid() {
      return factory();
    }
    makeUuid.setFactory = (newFactory) => {
      factory = newFactory;
    };
    makeUuid.reset = () => {
      factory = defaultFactory;
    };
    module.exports = makeUuid;
  }
});

// node_modules/automerge/frontend/constants.js
var require_constants = __commonJS({
  "node_modules/automerge/frontend/constants.js"(exports, module) {
    var OPTIONS = Symbol("_options");
    var CACHE = Symbol("_cache");
    var STATE = Symbol("_state");
    var OBJECT_ID = Symbol("_objectId");
    var CONFLICTS = Symbol("_conflicts");
    var CHANGE = Symbol("_change");
    var ELEM_IDS = Symbol("_elemIds");
    module.exports = {
      OPTIONS,
      CACHE,
      STATE,
      OBJECT_ID,
      CONFLICTS,
      CHANGE,
      ELEM_IDS
    };
  }
});

// node_modules/automerge/src/common.js
var require_common = __commonJS({
  "node_modules/automerge/src/common.js"(exports, module) {
    function isObject(obj) {
      return typeof obj === "object" && obj !== null;
    }
    function copyObject(obj) {
      if (!isObject(obj)) return {};
      let copy = {};
      for (let key of Object.keys(obj)) {
        copy[key] = obj[key];
      }
      return copy;
    }
    function parseOpId(opId) {
      const match = /^(\d+)@(.*)$/.exec(opId || "");
      if (!match) {
        throw new RangeError(`Not a valid opId: ${opId}`);
      }
      return { counter: parseInt(match[1], 10), actorId: match[2] };
    }
    function equalBytes(array1, array2) {
      if (!(array1 instanceof Uint8Array) || !(array2 instanceof Uint8Array)) {
        throw new TypeError("equalBytes can only compare Uint8Arrays");
      }
      if (array1.byteLength !== array2.byteLength) return false;
      for (let i = 0; i < array1.byteLength; i++) {
        if (array1[i] !== array2[i]) return false;
      }
      return true;
    }
    function createArrayOfNulls(length) {
      const array = new Array(length);
      for (let i = 0; i < length; i++) array[i] = null;
      return array;
    }
    module.exports = {
      isObject,
      copyObject,
      parseOpId,
      equalBytes,
      createArrayOfNulls
    };
  }
});

// node_modules/automerge/frontend/text.js
var require_text = __commonJS({
  "node_modules/automerge/frontend/text.js"(exports, module) {
    var { OBJECT_ID } = require_constants();
    var { isObject } = require_common();
    var Text = class {
      constructor(text) {
        if (typeof text === "string") {
          const elems = [...text].map((value) => ({ value }));
          return instantiateText(void 0, elems);
        } else if (Array.isArray(text)) {
          const elems = text.map((value) => ({ value }));
          return instantiateText(void 0, elems);
        } else if (text === void 0) {
          return instantiateText(void 0, []);
        } else {
          throw new TypeError(`Unsupported initial value for Text: ${text}`);
        }
      }
      get length() {
        return this.elems.length;
      }
      get(index) {
        const value = this.elems[index].value;
        if (this.context && isObject(value)) {
          const objectId = value[OBJECT_ID];
          const path = this.path.concat([{ key: index, objectId }]);
          return this.context.instantiateObject(path, objectId);
        } else {
          return value;
        }
      }
      getElemId(index) {
        return this.elems[index].elemId;
      }
      /**
       * Iterates over the text elements character by character, including any
       * inline objects.
       */
      [Symbol.iterator]() {
        let elems = this.elems, index = -1;
        return {
          next() {
            index += 1;
            if (index < elems.length) {
              return { done: false, value: elems[index].value };
            } else {
              return { done: true };
            }
          }
        };
      }
      /**
       * Returns the content of the Text object as a simple string, ignoring any
       * non-character elements.
       */
      toString() {
        let str = "";
        for (const elem of this.elems) {
          if (typeof elem.value === "string") str += elem.value;
        }
        return str;
      }
      /**
       * Returns the content of the Text object as a sequence of strings,
       * interleaved with non-character elements.
       *
       * For example, the value ['a', 'b', {x: 3}, 'c', 'd'] has spans:
       * => ['ab', {x: 3}, 'cd']
       */
      toSpans() {
        let spans = [];
        let chars = "";
        for (const elem of this.elems) {
          if (typeof elem.value === "string") {
            chars += elem.value;
          } else {
            if (chars.length > 0) {
              spans.push(chars);
              chars = "";
            }
            spans.push(elem.value);
          }
        }
        if (chars.length > 0) {
          spans.push(chars);
        }
        return spans;
      }
      /**
       * Returns the content of the Text object as a simple string, so that the
       * JSON serialization of an Automerge document represents text nicely.
       */
      toJSON() {
        return this.toString();
      }
      /**
       * Returns a writeable instance of this object. This instance is returned when
       * the text object is accessed within a change callback. `context` is the
       * proxy context that keeps track of the mutations.
       */
      getWriteable(context, path) {
        if (!this[OBJECT_ID]) {
          throw new RangeError("getWriteable() requires the objectId to be set");
        }
        const instance = instantiateText(this[OBJECT_ID], this.elems);
        instance.context = context;
        instance.path = path;
        return instance;
      }
      /**
       * Updates the list item at position `index` to a new value `value`.
       */
      set(index, value) {
        if (this.context) {
          this.context.setListIndex(this.path, index, value);
        } else if (!this[OBJECT_ID]) {
          this.elems[index].value = value;
        } else {
          throw new TypeError("Automerge.Text object cannot be modified outside of a change block");
        }
        return this;
      }
      /**
       * Inserts new list items `values` starting at position `index`.
       */
      insertAt(index, ...values) {
        if (this.context) {
          this.context.splice(this.path, index, 0, values);
        } else if (!this[OBJECT_ID]) {
          this.elems.splice(index, 0, ...values.map((value) => ({ value })));
        } else {
          throw new TypeError("Automerge.Text object cannot be modified outside of a change block");
        }
        return this;
      }
      /**
       * Deletes `numDelete` list items starting at position `index`.
       * if `numDelete` is not given, one item is deleted.
       */
      deleteAt(index, numDelete = 1) {
        if (this.context) {
          this.context.splice(this.path, index, numDelete, []);
        } else if (!this[OBJECT_ID]) {
          this.elems.splice(index, numDelete);
        } else {
          throw new TypeError("Automerge.Text object cannot be modified outside of a change block");
        }
        return this;
      }
    };
    for (let method of [
      "concat",
      "every",
      "filter",
      "find",
      "findIndex",
      "forEach",
      "includes",
      "indexOf",
      "join",
      "lastIndexOf",
      "map",
      "reduce",
      "reduceRight",
      "slice",
      "some",
      "toLocaleString"
    ]) {
      Text.prototype[method] = function(...args) {
        const array = [...this];
        return array[method](...args);
      };
    }
    function instantiateText(objectId, elems) {
      const instance = Object.create(Text.prototype);
      instance[OBJECT_ID] = objectId;
      instance.elems = elems;
      return instance;
    }
    module.exports = { Text, instantiateText };
  }
});

// node_modules/automerge/frontend/table.js
var require_table = __commonJS({
  "node_modules/automerge/frontend/table.js"(exports, module) {
    var { OBJECT_ID, CONFLICTS } = require_constants();
    var { isObject, copyObject } = require_common();
    function compareRows(properties, row1, row2) {
      for (let prop of properties) {
        if (row1[prop] === row2[prop]) continue;
        if (typeof row1[prop] === "number" && typeof row2[prop] === "number") {
          return row1[prop] - row2[prop];
        } else {
          const prop1 = "" + row1[prop], prop2 = "" + row2[prop];
          if (prop1 === prop2) continue;
          if (prop1 < prop2) return -1;
          else return 1;
        }
      }
      return 0;
    }
    var Table = class {
      /**
       * This constructor is used by application code when creating a new Table
       * object within a change callback.
       */
      constructor() {
        this.entries = Object.freeze({});
        this.opIds = Object.freeze({});
        Object.freeze(this);
      }
      /**
       * Looks up a row in the table by its unique ID.
       */
      byId(id) {
        return this.entries[id];
      }
      /**
       * Returns an array containing the unique IDs of all rows in the table, in no
       * particular order.
       */
      get ids() {
        return Object.keys(this.entries).filter((key) => {
          const entry = this.entries[key];
          return isObject(entry) && entry.id === key;
        });
      }
      /**
       * Returns the number of rows in the table.
       */
      get count() {
        return this.ids.length;
      }
      /**
       * Returns an array containing all of the rows in the table, in no particular
       * order.
       */
      get rows() {
        return this.ids.map((id) => this.byId(id));
      }
      /**
       * The standard JavaScript `filter()` method, which passes each row to the
       * callback function and returns all rows for which the it returns true.
       */
      filter(callback, thisArg) {
        return this.rows.filter(callback, thisArg);
      }
      /**
       * The standard JavaScript `find()` method, which passes each row to the
       * callback function and returns the first row for which it returns true.
       */
      find(callback, thisArg) {
        return this.rows.find(callback, thisArg);
      }
      /**
       * The standard JavaScript `map()` method, which passes each row to the
       * callback function and returns a list of its return values.
       */
      map(callback, thisArg) {
        return this.rows.map(callback, thisArg);
      }
      /**
      * Returns the list of rows, sorted by one of the following:
      * - If a function argument is given, it compares rows as per
      *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description
      * - If a string argument is given, it is interpreted as a column name and
      *   rows are sorted according to that column.
      * - If an array of strings is given, it is interpreted as a list of column
      *   names, and rows are sorted lexicographically by those columns.
      * - If no argument is given, it sorts by row ID by default.
      */
      sort(arg) {
        if (typeof arg === "function") {
          return this.rows.sort(arg);
        } else if (typeof arg === "string") {
          return this.rows.sort((row1, row2) => compareRows([arg], row1, row2));
        } else if (Array.isArray(arg)) {
          return this.rows.sort((row1, row2) => compareRows(arg, row1, row2));
        } else if (arg === void 0) {
          return this.rows.sort((row1, row2) => compareRows(["id"], row1, row2));
        } else {
          throw new TypeError(`Unsupported sorting argument: ${arg}`);
        }
      }
      /**
       * When iterating over a table, you get all rows in the table, in no
       * particular order.
       */
      [Symbol.iterator]() {
        let rows = this.rows, index = -1;
        return {
          next() {
            index += 1;
            if (index < rows.length) {
              return { done: false, value: rows[index] };
            } else {
              return { done: true };
            }
          }
        };
      }
      /**
       * Returns a shallow clone of this object. This clone is used while applying
       * a patch to the table, and `freeze()` is called on it when we have finished
       * applying the patch.
       */
      _clone() {
        if (!this[OBJECT_ID]) {
          throw new RangeError("clone() requires the objectId to be set");
        }
        return instantiateTable(this[OBJECT_ID], copyObject(this.entries), copyObject(this.opIds));
      }
      /**
       * Sets the entry with key `id` to `value`. `opId` is the ID of the operation
       * performing this assignment. This method is for internal use only; it is
       * not part of the public API of Automerge.Table.
       */
      _set(id, value, opId) {
        if (Object.isFrozen(this.entries)) {
          throw new Error("A table can only be modified in a change function");
        }
        if (isObject(value) && !Array.isArray(value)) {
          Object.defineProperty(value, "id", { value: id, enumerable: true });
        }
        this.entries[id] = value;
        this.opIds[id] = opId;
      }
      /**
       * Removes the row with unique ID `id` from the table.
       */
      remove(id) {
        if (Object.isFrozen(this.entries)) {
          throw new Error("A table can only be modified in a change function");
        }
        delete this.entries[id];
        delete this.opIds[id];
      }
      /**
       * Makes this object immutable. This is called after a change has been made.
       */
      _freeze() {
        Object.freeze(this.entries);
        Object.freeze(this.opIds);
        Object.freeze(this);
      }
      /**
       * Returns a writeable instance of this table. This instance is returned when
       * the table is accessed within a change callback. `context` is the proxy
       * context that keeps track of the mutations.
       */
      getWriteable(context, path) {
        if (!this[OBJECT_ID]) {
          throw new RangeError("getWriteable() requires the objectId to be set");
        }
        const instance = Object.create(WriteableTable.prototype);
        instance[OBJECT_ID] = this[OBJECT_ID];
        instance.context = context;
        instance.entries = this.entries;
        instance.opIds = this.opIds;
        instance.path = path;
        return instance;
      }
      /**
       * Returns an object containing the table entries, indexed by objectID,
       * for serializing an Automerge document to JSON.
       */
      toJSON() {
        const rows = {};
        for (let id of this.ids) rows[id] = this.byId(id);
        return rows;
      }
    };
    var WriteableTable = class extends Table {
      /**
       * Returns a proxied version of the row with ID `id`. This row object can be
       * modified within a change callback.
       */
      byId(id) {
        if (isObject(this.entries[id]) && this.entries[id].id === id) {
          const objectId = this.entries[id][OBJECT_ID];
          const path = this.path.concat([{ key: id, objectId }]);
          return this.context.instantiateObject(path, objectId, ["id"]);
        }
      }
      /**
       * Adds a new row to the table. The row is given as a map from
       * column name to value. Returns the objectId of the new row.
       */
      add(row) {
        return this.context.addTableRow(this.path, row);
      }
      /**
       * Removes the row with ID `id` from the table. Throws an exception if the row
       * does not exist in the table.
       */
      remove(id) {
        if (isObject(this.entries[id]) && this.entries[id].id === id) {
          this.context.deleteTableRow(this.path, id, this.opIds[id]);
        } else {
          throw new RangeError(`There is no row with ID ${id} in this table`);
        }
      }
    };
    function instantiateTable(objectId, entries, opIds) {
      const instance = Object.create(Table.prototype);
      if (!objectId) {
        throw new RangeError("instantiateTable requires an objectId to be given");
      }
      instance[OBJECT_ID] = objectId;
      instance[CONFLICTS] = Object.freeze({});
      instance.entries = entries || {};
      instance.opIds = opIds || {};
      return instance;
    }
    module.exports = { Table, instantiateTable };
  }
});

// node_modules/automerge/frontend/counter.js
var require_counter = __commonJS({
  "node_modules/automerge/frontend/counter.js"(exports, module) {
    var Counter = class {
      constructor(value) {
        this.value = value || 0;
        Object.freeze(this);
      }
      /**
       * A peculiar JavaScript language feature from its early days: if the object
       * `x` has a `valueOf()` method that returns a number, you can use numerical
       * operators on the object `x` directly, such as `x + 1` or `x < 4`.
       * This method is also called when coercing a value to a string by
       * concatenating it with another string, as in `x + ''`.
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf
       */
      valueOf() {
        return this.value;
      }
      /**
       * Returns the counter value as a decimal string. If `x` is a counter object,
       * this method is called e.g. when you do `['value: ', x].join('')` or when
       * you use string interpolation: `value: ${x}`.
       */
      toString() {
        return this.valueOf().toString();
      }
      /**
       * Returns the counter value, so that a JSON serialization of an Automerge
       * document represents the counter simply as an integer.
       */
      toJSON() {
        return this.value;
      }
    };
    var WriteableCounter = class extends Counter {
      /**
       * Increases the value of the counter by `delta`. If `delta` is not given,
       * increases the value of the counter by 1.
       */
      increment(delta) {
        delta = typeof delta === "number" ? delta : 1;
        this.context.increment(this.path, this.key, delta);
        this.value += delta;
        return this.value;
      }
      /**
       * Decreases the value of the counter by `delta`. If `delta` is not given,
       * decreases the value of the counter by 1.
       */
      decrement(delta) {
        return this.increment(typeof delta === "number" ? -delta : -1);
      }
    };
    function getWriteableCounter(value, context, path, objectId, key) {
      const instance = Object.create(WriteableCounter.prototype);
      instance.value = value;
      instance.context = context;
      instance.path = path;
      instance.objectId = objectId;
      instance.key = key;
      return instance;
    }
    module.exports = { Counter, getWriteableCounter };
  }
});

// node_modules/automerge/frontend/apply_patch.js
var require_apply_patch = __commonJS({
  "node_modules/automerge/frontend/apply_patch.js"(exports, module) {
    var { isObject, copyObject, parseOpId } = require_common();
    var { OBJECT_ID, CONFLICTS, ELEM_IDS } = require_constants();
    var { instantiateText } = require_text();
    var { instantiateTable } = require_table();
    var { Counter } = require_counter();
    function getValue(patch, object, updated) {
      if (patch.objectId) {
        if (object && object[OBJECT_ID] !== patch.objectId) {
          object = void 0;
        }
        return interpretPatch(patch, object, updated);
      } else if (patch.datatype === "timestamp") {
        return new Date(patch.value);
      } else if (patch.datatype === "counter") {
        return new Counter(patch.value);
      } else {
        return patch.value;
      }
    }
    function lamportCompare(ts1, ts2) {
      const regex = /^(\d+)@(.*)$/;
      const time1 = regex.test(ts1) ? parseOpId(ts1) : { counter: 0, actorId: ts1 };
      const time2 = regex.test(ts2) ? parseOpId(ts2) : { counter: 0, actorId: ts2 };
      if (time1.counter < time2.counter) return -1;
      if (time1.counter > time2.counter) return 1;
      if (time1.actorId < time2.actorId) return -1;
      if (time1.actorId > time2.actorId) return 1;
      return 0;
    }
    function applyProperties(props, object, conflicts, updated) {
      if (!props) return;
      for (let key of Object.keys(props)) {
        const values = {}, opIds = Object.keys(props[key]).sort(lamportCompare).reverse();
        for (let opId of opIds) {
          const subpatch = props[key][opId];
          if (conflicts[key] && conflicts[key][opId]) {
            values[opId] = getValue(subpatch, conflicts[key][opId], updated);
          } else {
            values[opId] = getValue(subpatch, void 0, updated);
          }
        }
        if (opIds.length === 0) {
          delete object[key];
          delete conflicts[key];
        } else {
          object[key] = values[opIds[0]];
          conflicts[key] = values;
        }
      }
    }
    function cloneMapObject(originalObject, objectId) {
      const object = copyObject(originalObject);
      const conflicts = copyObject(originalObject ? originalObject[CONFLICTS] : void 0);
      Object.defineProperty(object, OBJECT_ID, { value: objectId });
      Object.defineProperty(object, CONFLICTS, { value: conflicts });
      return object;
    }
    function updateMapObject(patch, obj, updated) {
      const objectId = patch.objectId;
      if (!updated[objectId]) {
        updated[objectId] = cloneMapObject(obj, objectId);
      }
      const object = updated[objectId];
      applyProperties(patch.props, object, object[CONFLICTS], updated);
      return object;
    }
    function updateTableObject(patch, obj, updated) {
      const objectId = patch.objectId;
      if (!updated[objectId]) {
        updated[objectId] = obj ? obj._clone() : instantiateTable(objectId);
      }
      const object = updated[objectId];
      for (let key of Object.keys(patch.props || {})) {
        const opIds = Object.keys(patch.props[key]);
        if (opIds.length === 0) {
          object.remove(key);
        } else if (opIds.length === 1) {
          const subpatch = patch.props[key][opIds[0]];
          object._set(key, getValue(subpatch, object.byId(key), updated), opIds[0]);
        } else {
          throw new RangeError("Conflicts are not supported on properties of a table");
        }
      }
      return object;
    }
    function cloneListObject(originalList, objectId) {
      const list = originalList ? originalList.slice() : [];
      const conflicts = originalList && originalList[CONFLICTS] ? originalList[CONFLICTS].slice() : [];
      const elemIds = originalList && originalList[ELEM_IDS] ? originalList[ELEM_IDS].slice() : [];
      Object.defineProperty(list, OBJECT_ID, { value: objectId });
      Object.defineProperty(list, CONFLICTS, { value: conflicts });
      Object.defineProperty(list, ELEM_IDS, { value: elemIds });
      return list;
    }
    function updateListObject(patch, obj, updated) {
      const objectId = patch.objectId;
      if (!updated[objectId]) {
        updated[objectId] = cloneListObject(obj, objectId);
      }
      const list = updated[objectId], conflicts = list[CONFLICTS], elemIds = list[ELEM_IDS];
      for (let i = 0; i < patch.edits.length; i++) {
        const edit = patch.edits[i];
        if (edit.action === "insert" || edit.action === "update") {
          const oldValue = conflicts[edit.index] && conflicts[edit.index][edit.opId];
          let lastValue = getValue(edit.value, oldValue, updated);
          let values = { [edit.opId]: lastValue };
          while (i < patch.edits.length - 1 && patch.edits[i + 1].index === edit.index && patch.edits[i + 1].action === "update") {
            i++;
            const conflict = patch.edits[i];
            const oldValue2 = conflicts[conflict.index] && conflicts[conflict.index][conflict.opId];
            lastValue = getValue(conflict.value, oldValue2, updated);
            values[conflict.opId] = lastValue;
          }
          if (edit.action === "insert") {
            list.splice(edit.index, 0, lastValue);
            conflicts.splice(edit.index, 0, values);
            elemIds.splice(edit.index, 0, edit.elemId);
          } else {
            list[edit.index] = lastValue;
            conflicts[edit.index] = values;
          }
        } else if (edit.action === "multi-insert") {
          const startElemId = parseOpId(edit.elemId), newElems = [], newValues = [], newConflicts = [];
          const datatype = edit.datatype;
          edit.values.forEach((value, index) => {
            const elemId = `${startElemId.counter + index}@${startElemId.actorId}`;
            value = getValue({ value, datatype }, void 0, updated);
            newValues.push(value);
            newConflicts.push({ [elemId]: { value, datatype, type: "value" } });
            newElems.push(elemId);
          });
          list.splice(edit.index, 0, ...newValues);
          conflicts.splice(edit.index, 0, ...newConflicts);
          elemIds.splice(edit.index, 0, ...newElems);
        } else if (edit.action === "remove") {
          list.splice(edit.index, edit.count);
          conflicts.splice(edit.index, edit.count);
          elemIds.splice(edit.index, edit.count);
        }
      }
      return list;
    }
    function updateTextObject(patch, obj, updated) {
      const objectId = patch.objectId;
      let elems;
      if (updated[objectId]) {
        elems = updated[objectId].elems;
      } else if (obj) {
        elems = obj.elems.slice();
      } else {
        elems = [];
      }
      for (const edit of patch.edits) {
        if (edit.action === "insert") {
          const value = getValue(edit.value, void 0, updated);
          const elem = { elemId: edit.elemId, pred: [edit.opId], value };
          elems.splice(edit.index, 0, elem);
        } else if (edit.action === "multi-insert") {
          const startElemId = parseOpId(edit.elemId);
          const datatype = edit.datatype;
          const newElems = edit.values.map((value, index) => {
            value = getValue({ datatype, value }, void 0, updated);
            const elemId = `${startElemId.counter + index}@${startElemId.actorId}`;
            return { elemId, pred: [elemId], value };
          });
          elems.splice(edit.index, 0, ...newElems);
        } else if (edit.action === "update") {
          const elemId = elems[edit.index].elemId;
          const value = getValue(edit.value, elems[edit.index].value, updated);
          elems[edit.index] = { elemId, pred: [edit.opId], value };
        } else if (edit.action === "remove") {
          elems.splice(edit.index, edit.count);
        }
      }
      updated[objectId] = instantiateText(objectId, elems);
      return updated[objectId];
    }
    function interpretPatch(patch, obj, updated) {
      if (isObject(obj) && (!patch.props || Object.keys(patch.props).length === 0) && (!patch.edits || patch.edits.length === 0) && !updated[patch.objectId]) {
        return obj;
      }
      if (patch.type === "map") {
        return updateMapObject(patch, obj, updated);
      } else if (patch.type === "table") {
        return updateTableObject(patch, obj, updated);
      } else if (patch.type === "list") {
        return updateListObject(patch, obj, updated);
      } else if (patch.type === "text") {
        return updateTextObject(patch, obj, updated);
      } else {
        throw new TypeError(`Unknown object type: ${patch.type}`);
      }
    }
    function cloneRootObject(root) {
      if (root[OBJECT_ID] !== "_root") {
        throw new RangeError(`Not the root object: ${root[OBJECT_ID]}`);
      }
      return cloneMapObject(root, "_root");
    }
    module.exports = {
      interpretPatch,
      cloneRootObject
    };
  }
});

// node_modules/automerge/frontend/proxies.js
var require_proxies = __commonJS({
  "node_modules/automerge/frontend/proxies.js"(exports, module) {
    var { OBJECT_ID, CHANGE, STATE } = require_constants();
    var { createArrayOfNulls } = require_common();
    var { Text } = require_text();
    var { Table } = require_table();
    function parseListIndex(key) {
      if (typeof key === "string" && /^[0-9]+$/.test(key)) key = parseInt(key, 10);
      if (typeof key !== "number") {
        throw new TypeError("A list index must be a number, but you passed " + JSON.stringify(key));
      }
      if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {
        throw new RangeError("A list index must be positive, but you passed " + key);
      }
      return key;
    }
    function listMethods(context, listId, path) {
      const methods = {
        deleteAt(index, numDelete) {
          context.splice(path, parseListIndex(index), numDelete || 1, []);
          return this;
        },
        fill(value, start, end) {
          let list = context.getObject(listId);
          for (let index = parseListIndex(start || 0); index < parseListIndex(end || list.length); index++) {
            context.setListIndex(path, index, value);
          }
          return this;
        },
        indexOf(o, start = 0) {
          const id = o[OBJECT_ID];
          if (id) {
            const list = context.getObject(listId);
            for (let index = start; index < list.length; index++) {
              if (list[index][OBJECT_ID] === id) {
                return index;
              }
            }
            return -1;
          } else {
            return context.getObject(listId).indexOf(o, start);
          }
        },
        insertAt(index, ...values) {
          context.splice(path, parseListIndex(index), 0, values);
          return this;
        },
        pop() {
          let list = context.getObject(listId);
          if (list.length == 0) return;
          const last = context.getObjectField(path, listId, list.length - 1);
          context.splice(path, list.length - 1, 1, []);
          return last;
        },
        push(...values) {
          let list = context.getObject(listId);
          context.splice(path, list.length, 0, values);
          return context.getObject(listId).length;
        },
        shift() {
          let list = context.getObject(listId);
          if (list.length == 0) return;
          const first = context.getObjectField(path, listId, 0);
          context.splice(path, 0, 1, []);
          return first;
        },
        splice(start, deleteCount, ...values) {
          let list = context.getObject(listId);
          start = parseListIndex(start);
          if (deleteCount === void 0 || deleteCount > list.length - start) {
            deleteCount = list.length - start;
          }
          const deleted = [];
          for (let n = 0; n < deleteCount; n++) {
            deleted.push(context.getObjectField(path, listId, start + n));
          }
          context.splice(path, start, deleteCount, values);
          return deleted;
        },
        unshift(...values) {
          context.splice(path, 0, 0, values);
          return context.getObject(listId).length;
        }
      };
      for (let iterator of ["entries", "keys", "values"]) {
        let list = context.getObject(listId);
        methods[iterator] = () => list[iterator]();
      }
      for (let method of [
        "concat",
        "every",
        "filter",
        "find",
        "findIndex",
        "forEach",
        "includes",
        "join",
        "lastIndexOf",
        "map",
        "reduce",
        "reduceRight",
        "slice",
        "some",
        "toLocaleString",
        "toString"
      ]) {
        methods[method] = (...args) => {
          const list = context.getObject(listId).map((item, index) => context.getObjectField(path, listId, index));
          return list[method](...args);
        };
      }
      return methods;
    }
    var MapHandler = {
      get(target, key) {
        const { context, objectId, path } = target;
        if (key === OBJECT_ID) return objectId;
        if (key === CHANGE) return context;
        if (key === STATE) return { actorId: context.actorId };
        return context.getObjectField(path, objectId, key);
      },
      set(target, key, value) {
        const { context, path, readonly } = target;
        if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {
          throw new RangeError(`Object property "${key}" cannot be modified`);
        }
        context.setMapKey(path, key, value);
        return true;
      },
      deleteProperty(target, key) {
        const { context, path, readonly } = target;
        if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {
          throw new RangeError(`Object property "${key}" cannot be modified`);
        }
        context.deleteMapKey(path, key);
        return true;
      },
      has(target, key) {
        const { context, objectId } = target;
        return [OBJECT_ID, CHANGE].includes(key) || key in context.getObject(objectId);
      },
      getOwnPropertyDescriptor(target, key) {
        const { context, objectId } = target;
        const object = context.getObject(objectId);
        if (key in object) {
          return {
            configurable: true,
            enumerable: true,
            value: context.getObjectField(objectId, key)
          };
        }
      },
      ownKeys(target) {
        const { context, objectId } = target;
        return Object.keys(context.getObject(objectId));
      }
    };
    var ListHandler = {
      get(target, key) {
        const [context, objectId, path] = target;
        if (key === Symbol.iterator) return context.getObject(objectId)[Symbol.iterator];
        if (key === OBJECT_ID) return objectId;
        if (key === CHANGE) return context;
        if (key === "length") return context.getObject(objectId).length;
        if (typeof key === "string" && /^[0-9]+$/.test(key)) {
          return context.getObjectField(path, objectId, parseListIndex(key));
        }
        return listMethods(context, objectId, path)[key];
      },
      set(target, key, value) {
        const [context, objectId, path] = target;
        if (key === "length") {
          if (typeof value !== "number") {
            throw new RangeError("Invalid array length");
          }
          const length = context.getObject(objectId).length;
          if (length > value) {
            context.splice(path, value, length - value, []);
          } else {
            context.splice(path, length, 0, createArrayOfNulls(value - length));
          }
        } else {
          context.setListIndex(path, parseListIndex(key), value);
        }
        return true;
      },
      deleteProperty(target, key) {
        const [
          context,
          /* objectId */
          ,
          path
        ] = target;
        context.splice(path, parseListIndex(key), 1, []);
        return true;
      },
      has(target, key) {
        const [
          context,
          objectId
          /* path */
        ] = target;
        if (typeof key === "string" && /^[0-9]+$/.test(key)) {
          return parseListIndex(key) < context.getObject(objectId).length;
        }
        return ["length", OBJECT_ID, CHANGE].includes(key);
      },
      getOwnPropertyDescriptor(target, key) {
        const [
          context,
          objectId
          /* path */
        ] = target;
        const object = context.getObject(objectId);
        if (key === "length") return { writable: true, value: object.length };
        if (key === OBJECT_ID) return { configurable: false, enumerable: false, value: objectId };
        if (typeof key === "string" && /^[0-9]+$/.test(key)) {
          const index = parseListIndex(key);
          if (index < object.length) return {
            configurable: true,
            enumerable: true,
            value: context.getObjectField(objectId, index)
          };
        }
      },
      ownKeys(target) {
        const [
          context,
          objectId
          /* path */
        ] = target;
        const object = context.getObject(objectId);
        let keys = ["length"];
        for (let key of Object.keys(object)) keys.push(key);
        return keys;
      }
    };
    function mapProxy(context, objectId, path, readonly) {
      return new Proxy({ context, objectId, path, readonly }, MapHandler);
    }
    function listProxy(context, objectId, path) {
      return new Proxy([context, objectId, path], ListHandler);
    }
    function instantiateProxy(path, objectId, readonly) {
      const object = this.getObject(objectId);
      if (Array.isArray(object)) {
        return listProxy(this, objectId, path);
      } else if (object instanceof Text || object instanceof Table) {
        return object.getWriteable(this, path);
      } else {
        return mapProxy(this, objectId, path, readonly);
      }
    }
    function rootObjectProxy(context) {
      context.instantiateObject = instantiateProxy;
      return mapProxy(context, "_root", []);
    }
    module.exports = { rootObjectProxy };
  }
});

// node_modules/automerge/frontend/numbers.js
var require_numbers = __commonJS({
  "node_modules/automerge/frontend/numbers.js"(exports, module) {
    var Int = class {
      constructor(value) {
        if (!(Number.isInteger(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER)) {
          throw new RangeError(`Value ${value} cannot be a uint`);
        }
        this.value = value;
        Object.freeze(this);
      }
    };
    var Uint = class {
      constructor(value) {
        if (!(Number.isInteger(value) && value <= Number.MAX_SAFE_INTEGER && value >= 0)) {
          throw new RangeError(`Value ${value} cannot be a uint`);
        }
        this.value = value;
        Object.freeze(this);
      }
    };
    var Float64 = class {
      constructor(value) {
        if (typeof value !== "number") {
          throw new RangeError(`Value ${value} cannot be a float64`);
        }
        this.value = value || 0;
        Object.freeze(this);
      }
    };
    module.exports = { Int, Uint, Float64 };
  }
});

// node_modules/automerge/frontend/context.js
var require_context = __commonJS({
  "node_modules/automerge/frontend/context.js"(exports, module) {
    var { CACHE, OBJECT_ID, CONFLICTS, ELEM_IDS, STATE } = require_constants();
    var { interpretPatch } = require_apply_patch();
    var { Text } = require_text();
    var { Table } = require_table();
    var { Counter, getWriteableCounter } = require_counter();
    var { Int, Uint, Float64 } = require_numbers();
    var { isObject, parseOpId, createArrayOfNulls } = require_common();
    var uuid = require_uuid2();
    var Context = class {
      constructor(doc, actorId, applyPatch) {
        this.actorId = actorId;
        this.nextOpNum = doc[STATE].maxOp + 1;
        this.cache = doc[CACHE];
        this.updated = {};
        this.ops = [];
        this.applyPatch = applyPatch ? applyPatch : interpretPatch;
      }
      /**
       * Adds an operation object to the list of changes made in the current context.
       */
      addOp(operation) {
        this.ops.push(operation);
        if (operation.action === "set" && operation.values) {
          this.nextOpNum += operation.values.length;
        } else if (operation.action === "del" && operation.multiOp) {
          this.nextOpNum += operation.multiOp;
        } else {
          this.nextOpNum += 1;
        }
      }
      /**
       * Returns the operation ID of the next operation to be added to the context.
       */
      nextOpId() {
        return `${this.nextOpNum}@${this.actorId}`;
      }
      /**
       * Takes a value and returns an object describing the value (in the format used by patches).
       */
      getValueDescription(value) {
        if (!["object", "boolean", "number", "string"].includes(typeof value)) {
          throw new TypeError(`Unsupported type of value: ${typeof value}`);
        }
        if (isObject(value)) {
          if (value instanceof Date) {
            return { type: "value", value: value.getTime(), datatype: "timestamp" };
          } else if (value instanceof Int) {
            return { type: "value", value: value.value, datatype: "int" };
          } else if (value instanceof Uint) {
            return { type: "value", value: value.value, datatype: "uint" };
          } else if (value instanceof Float64) {
            return { type: "value", value: value.value, datatype: "float64" };
          } else if (value instanceof Counter) {
            return { type: "value", value: value.value, datatype: "counter" };
          } else {
            const objectId = value[OBJECT_ID], type = this.getObjectType(objectId);
            if (!objectId) {
              throw new RangeError(`Object ${JSON.stringify(value)} has no objectId`);
            }
            if (type === "list" || type === "text") {
              return { objectId, type, edits: [] };
            } else {
              return { objectId, type, props: {} };
            }
          }
        } else if (typeof value === "number") {
          if (Number.isInteger(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER) {
            return { type: "value", value, datatype: "int" };
          } else {
            return { type: "value", value, datatype: "float64" };
          }
        } else {
          return { type: "value", value };
        }
      }
      /**
       * Builds the values structure describing a single property in a patch. Finds all the values of
       * property `key` of `object` (there might be multiple values in the case of a conflict), and
       * returns an object that maps operation IDs to descriptions of values.
       */
      getValuesDescriptions(path, object, key) {
        if (object instanceof Table) {
          const value = object.byId(key);
          const opId = object.opIds[key];
          return value ? { [opId]: this.getValueDescription(value) } : {};
        } else if (object instanceof Text) {
          const value = object.get(key);
          const elemId = object.getElemId(key);
          return value ? { [elemId]: this.getValueDescription(value) } : {};
        } else {
          const conflicts = object[CONFLICTS][key], values = {};
          if (!conflicts) {
            throw new RangeError(`No children at key ${key} of path ${JSON.stringify(path)}`);
          }
          for (let opId of Object.keys(conflicts)) {
            values[opId] = this.getValueDescription(conflicts[opId]);
          }
          return values;
        }
      }
      /**
       * Returns the value at property `key` of object `object`. In the case of a conflict, returns
       * the value whose assignment operation has the ID `opId`.
       */
      getPropertyValue(object, key, opId) {
        if (object instanceof Table) {
          return object.byId(key);
        } else if (object instanceof Text) {
          return object.get(key);
        } else {
          return object[CONFLICTS][key][opId];
        }
      }
      /**
       * Recurses along `path` into the patch object `patch`, creating nodes along the way as needed
       * by mutating the patch object. Returns the subpatch at the given path.
       */
      getSubpatch(patch, path) {
        if (path.length == 0) return patch;
        let subpatch = patch, object = this.getObject("_root");
        for (let pathElem of path) {
          let values = this.getValuesDescriptions(path, object, pathElem.key);
          if (subpatch.props) {
            if (!subpatch.props[pathElem.key]) {
              subpatch.props[pathElem.key] = values;
            }
          } else if (subpatch.edits) {
            for (const opId of Object.keys(values)) {
              subpatch.edits.push({ action: "update", index: pathElem.key, opId, value: values[opId] });
            }
          }
          let nextOpId = null;
          for (let opId of Object.keys(values)) {
            if (values[opId].objectId === pathElem.objectId) {
              nextOpId = opId;
            }
          }
          if (!nextOpId) {
            throw new RangeError(`Cannot find path object with objectId ${pathElem.objectId}`);
          }
          subpatch = values[nextOpId];
          object = this.getPropertyValue(object, pathElem.key, nextOpId);
        }
        return subpatch;
      }
      /**
       * Returns an object (not proxied) from the cache or updated set, as appropriate.
       */
      getObject(objectId) {
        const object = this.updated[objectId] || this.cache[objectId];
        if (!object) throw new RangeError(`Target object does not exist: ${objectId}`);
        return object;
      }
      /**
       * Returns a string that is either 'map', 'table', 'list', or 'text', indicating
       * the type of the object with ID `objectId`.
       */
      getObjectType(objectId) {
        if (objectId === "_root") return "map";
        const object = this.getObject(objectId);
        if (object instanceof Text) return "text";
        if (object instanceof Table) return "table";
        if (Array.isArray(object)) return "list";
        return "map";
      }
      /**
       * Returns the value associated with the property named `key` on the object
       * at path `path`. If the value is an object, returns a proxy for it.
       */
      getObjectField(path, objectId, key) {
        if (!["string", "number"].includes(typeof key)) return;
        const object = this.getObject(objectId);
        if (object[key] instanceof Counter) {
          return getWriteableCounter(object[key].value, this, path, objectId, key);
        } else if (isObject(object[key])) {
          const childId = object[key][OBJECT_ID];
          const subpath = path.concat([{ key, objectId: childId }]);
          return this.instantiateObject(subpath, childId);
        } else {
          return object[key];
        }
      }
      /**
       * Recursively creates Automerge versions of all the objects and nested objects in `value`,
       * constructing a patch and operations that describe the object tree. The new object is
       * assigned to the property `key` in the object with ID `obj`. If the object is a list or
       * text, `key` must be set to the list index being updated, and `elemId` must be set to the
       * elemId of the element being updated. If `insert` is true, we insert a new list element
       * (or text character) at index `key`, and `elemId` must be the elemId of the immediate
       * predecessor element (or the string '_head' if inserting at index 0). If the assignment
       * overwrites a previous value at this key/element, `pred` must be set to the array of the
       * prior operations we are overwriting (empty array if there is no existing value).
       */
      createNestedObjects(obj, key, value, insert, pred, elemId) {
        if (value[OBJECT_ID]) {
          throw new RangeError("Cannot create a reference to an existing document object");
        }
        const objectId = this.nextOpId();
        if (value instanceof Text) {
          this.addOp(elemId ? { action: "makeText", obj, elemId, insert, pred } : { action: "makeText", obj, key, insert, pred });
          const subpatch = { objectId, type: "text", edits: [] };
          this.insertListItems(subpatch, 0, [...value], true);
          return subpatch;
        } else if (value instanceof Table) {
          if (value.count > 0) {
            throw new RangeError("Assigning a non-empty Table object is not supported");
          }
          this.addOp(elemId ? { action: "makeTable", obj, elemId, insert, pred } : { action: "makeTable", obj, key, insert, pred });
          return { objectId, type: "table", props: {} };
        } else if (Array.isArray(value)) {
          this.addOp(elemId ? { action: "makeList", obj, elemId, insert, pred } : { action: "makeList", obj, key, insert, pred });
          const subpatch = { objectId, type: "list", edits: [] };
          this.insertListItems(subpatch, 0, value, true);
          return subpatch;
        } else {
          this.addOp(elemId ? { action: "makeMap", obj, elemId, insert, pred } : { action: "makeMap", obj, key, insert, pred });
          let props = {};
          for (let nested of Object.keys(value).sort()) {
            const opId = this.nextOpId();
            const valuePatch = this.setValue(objectId, nested, value[nested], false, []);
            props[nested] = { [opId]: valuePatch };
          }
          return { objectId, type: "map", props };
        }
      }
      /**
       * Records an assignment to a particular key in a map, or a particular index in a list.
       * `objectId` is the ID of the object being modified, `key` is the property name or list
       * index being updated, and `value` is the new value being assigned. If `insert` is true,
       * a new list element is inserted at index `key`, and `value` is assigned to that new list
       * element. `pred` is an array of opIds for previous values of the property being assigned,
       * which are overwritten by this operation. If the object being modified is a list or text,
       * `elemId` is the element ID of the list element being updated (if insert=false), or the
       * element ID of the list element immediately preceding the insertion (if insert=true).
       *
       * Returns a patch describing the new value. The return value is of the form
       * `{objectId, type, props}` if `value` is an object, or `{value, datatype}` if it is a
       * primitive value. For string, number, boolean, or null the datatype is omitted.
       */
      setValue(objectId, key, value, insert, pred, elemId) {
        if (!objectId) {
          throw new RangeError("setValue needs an objectId");
        }
        if (key === "") {
          throw new RangeError("The key of a map entry must not be an empty string");
        }
        if (isObject(value) && !(value instanceof Date) && !(value instanceof Counter) && !(value instanceof Int) && !(value instanceof Uint) && !(value instanceof Float64)) {
          return this.createNestedObjects(objectId, key, value, insert, pred, elemId);
        } else {
          const description = this.getValueDescription(value);
          const op = { action: "set", obj: objectId, insert, value: description.value, pred };
          if (elemId) op.elemId = elemId;
          else op.key = key;
          if (description.datatype) op.datatype = description.datatype;
          this.addOp(op);
          return description;
        }
      }
      /**
       * Constructs a new patch, calls `callback` with the subpatch at the location `path`,
       * and then immediately applies the patch to the document.
       */
      applyAtPath(path, callback) {
        let diff = { objectId: "_root", type: "map", props: {} };
        callback(this.getSubpatch(diff, path));
        this.applyPatch(diff, this.cache._root, this.updated);
      }
      /**
       * Updates the map object at path `path`, setting the property with name
       * `key` to `value`.
       */
      setMapKey(path, key, value) {
        if (typeof key !== "string") {
          throw new RangeError(`The key of a map entry must be a string, not ${typeof key}`);
        }
        const objectId = path.length === 0 ? "_root" : path[path.length - 1].objectId;
        const object = this.getObject(objectId);
        if (object[key] instanceof Counter) {
          throw new RangeError("Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.");
        }
        if (object[key] !== value || Object.keys(object[CONFLICTS][key] || {}).length > 1 || value === void 0) {
          this.applyAtPath(path, (subpatch) => {
            const pred = getPred(object, key);
            const opId = this.nextOpId();
            const valuePatch = this.setValue(objectId, key, value, false, pred);
            subpatch.props[key] = { [opId]: valuePatch };
          });
        }
      }
      /**
       * Updates the map object at path `path`, deleting the property `key`.
       */
      deleteMapKey(path, key) {
        const objectId = path.length === 0 ? "_root" : path[path.length - 1].objectId;
        const object = this.getObject(objectId);
        if (object[key] !== void 0) {
          const pred = getPred(object, key);
          this.addOp({ action: "del", obj: objectId, key, insert: false, pred });
          this.applyAtPath(path, (subpatch) => {
            subpatch.props[key] = {};
          });
        }
      }
      /**
       * Inserts a sequence of new list elements `values` into a list, starting at position `index`.
       * `newObject` is true if we are creating a new list object, and false if we are updating an
       * existing one. `subpatch` is the patch for the list object being modified. Mutates
       * `subpatch` to reflect the sequence of values.
       */
      insertListItems(subpatch, index, values, newObject) {
        const list = newObject ? [] : this.getObject(subpatch.objectId);
        if (index < 0 || index > list.length) {
          throw new RangeError(`List index ${index} is out of bounds for list of length ${list.length}`);
        }
        if (values.length === 0) return;
        let elemId = getElemId(list, index, true);
        const allPrimitive = values.every((v) => typeof v === "string" || typeof v === "number" || typeof v === "boolean" || v === null || isObject(v) && (v instanceof Date || v instanceof Counter || v instanceof Int || v instanceof Uint || v instanceof Float64));
        const allValueDescriptions = allPrimitive ? values.map((v) => this.getValueDescription(v)) : [];
        const allDatatypesSame = allValueDescriptions.every((t) => t.datatype === allValueDescriptions[0].datatype);
        if (allPrimitive && allDatatypesSame && values.length > 1) {
          const nextElemId = this.nextOpId();
          const datatype = allValueDescriptions[0].datatype;
          const values2 = allValueDescriptions.map((v) => v.value);
          const op = { action: "set", obj: subpatch.objectId, elemId, insert: true, values: values2, pred: [] };
          const edit = { action: "multi-insert", elemId: nextElemId, index, values: values2 };
          if (datatype) {
            op.datatype = datatype;
            edit.datatype = datatype;
          }
          this.addOp(op);
          subpatch.edits.push(edit);
        } else {
          for (let offset = 0; offset < values.length; offset++) {
            let nextElemId = this.nextOpId();
            const valuePatch = this.setValue(subpatch.objectId, index + offset, values[offset], true, [], elemId);
            elemId = nextElemId;
            subpatch.edits.push({ action: "insert", index: index + offset, elemId, opId: elemId, value: valuePatch });
          }
        }
      }
      /**
       * Updates the list object at path `path`, replacing the current value at
       * position `index` with the new value `value`.
       */
      setListIndex(path, index, value) {
        const objectId = path.length === 0 ? "_root" : path[path.length - 1].objectId;
        const list = this.getObject(objectId);
        if (index >= list.length) {
          const insertions = createArrayOfNulls(index - list.length);
          insertions.push(value);
          return this.splice(path, list.length, 0, insertions);
        }
        if (list[index] instanceof Counter) {
          throw new RangeError("Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.");
        }
        if (list[index] !== value || Object.keys(list[CONFLICTS][index] || {}).length > 1 || value === void 0) {
          this.applyAtPath(path, (subpatch) => {
            const pred = getPred(list, index);
            const opId = this.nextOpId();
            const valuePatch = this.setValue(objectId, index, value, false, pred, getElemId(list, index));
            subpatch.edits.push({ action: "update", index, opId, value: valuePatch });
          });
        }
      }
      /**
       * Updates the list object at path `path`, deleting `deletions` list elements starting from
       * list index `start`, and inserting the list of new elements `insertions` at that position.
       */
      splice(path, start, deletions, insertions) {
        const objectId = path.length === 0 ? "_root" : path[path.length - 1].objectId;
        let list = this.getObject(objectId);
        if (start < 0 || deletions < 0 || start > list.length - deletions) {
          throw new RangeError(`${deletions} deletions starting at index ${start} are out of bounds for list of length ${list.length}`);
        }
        if (deletions === 0 && insertions.length === 0) return;
        let patch = { diffs: { objectId: "_root", type: "map", props: {} } };
        let subpatch = this.getSubpatch(patch.diffs, path);
        if (deletions > 0) {
          let op, lastElemParsed, lastPredParsed;
          for (let i = 0; i < deletions; i++) {
            if (this.getObjectField(path, objectId, start + i) instanceof Counter) {
              throw new TypeError("Unsupported operation: deleting a counter from a list");
            }
            const thisElem = getElemId(list, start + i), thisElemParsed = parseOpId(thisElem);
            const thisPred = getPred(list, start + i);
            const thisPredParsed = thisPred.length === 1 ? parseOpId(thisPred[0]) : void 0;
            if (op && lastElemParsed && lastPredParsed && thisPredParsed && lastElemParsed.actorId === thisElemParsed.actorId && lastElemParsed.counter + 1 === thisElemParsed.counter && lastPredParsed.actorId === thisPredParsed.actorId && lastPredParsed.counter + 1 === thisPredParsed.counter) {
              op.multiOp = (op.multiOp || 1) + 1;
            } else {
              if (op) this.addOp(op);
              op = { action: "del", obj: objectId, elemId: thisElem, insert: false, pred: thisPred };
            }
            lastElemParsed = thisElemParsed;
            lastPredParsed = thisPredParsed;
          }
          this.addOp(op);
          subpatch.edits.push({ action: "remove", index: start, count: deletions });
        }
        if (insertions.length > 0) {
          this.insertListItems(subpatch, start, insertions, false);
        }
        this.applyPatch(patch.diffs, this.cache._root, this.updated);
      }
      /**
       * Updates the table object at path `path`, adding a new entry `row`.
       * Returns the objectId of the new row.
       */
      addTableRow(path, row) {
        if (!isObject(row) || Array.isArray(row)) {
          throw new TypeError("A table row must be an object");
        }
        if (row[OBJECT_ID]) {
          throw new TypeError("Cannot reuse an existing object as table row");
        }
        if (row.id) {
          throw new TypeError('A table row must not have an "id" property; it is generated automatically');
        }
        const id = uuid();
        const valuePatch = this.setValue(path[path.length - 1].objectId, id, row, false, []);
        this.applyAtPath(path, (subpatch) => {
          subpatch.props[id] = { [valuePatch.objectId]: valuePatch };
        });
        return id;
      }
      /**
       * Updates the table object at path `path`, deleting the row with ID `rowId`.
       * `pred` is the opId of the operation that originally created the row.
       */
      deleteTableRow(path, rowId, pred) {
        const objectId = path[path.length - 1].objectId, table = this.getObject(objectId);
        if (table.byId(rowId)) {
          this.addOp({ action: "del", obj: objectId, key: rowId, insert: false, pred: [pred] });
          this.applyAtPath(path, (subpatch) => {
            subpatch.props[rowId] = {};
          });
        }
      }
      /**
       * Adds the integer `delta` to the value of the counter located at property
       * `key` in the object at path `path`.
       */
      increment(path, key, delta) {
        const objectId = path.length === 0 ? "_root" : path[path.length - 1].objectId;
        const object = this.getObject(objectId);
        if (!(object[key] instanceof Counter)) {
          throw new TypeError("Only counter values can be incremented");
        }
        const type = this.getObjectType(objectId);
        const value = object[key].value + delta;
        const opId = this.nextOpId();
        const pred = getPred(object, key);
        if (type === "list" || type === "text") {
          const elemId = getElemId(object, key, false);
          this.addOp({ action: "inc", obj: objectId, elemId, value: delta, insert: false, pred });
        } else {
          this.addOp({ action: "inc", obj: objectId, key, value: delta, insert: false, pred });
        }
        this.applyAtPath(path, (subpatch) => {
          if (type === "list" || type === "text") {
            subpatch.edits.push({ action: "update", index: key, opId, value: { value, datatype: "counter" } });
          } else {
            subpatch.props[key] = { [opId]: { value, datatype: "counter" } };
          }
        });
      }
    };
    function getPred(object, key) {
      if (object instanceof Table) {
        return [object.opIds[key]];
      } else if (object instanceof Text) {
        return object.elems[key].pred;
      } else if (object[CONFLICTS]) {
        return object[CONFLICTS][key] ? Object.keys(object[CONFLICTS][key]) : [];
      } else {
        return [];
      }
    }
    function getElemId(list, index, insert = false) {
      if (insert) {
        if (index === 0) return "_head";
        index -= 1;
      }
      if (list[ELEM_IDS]) return list[ELEM_IDS][index];
      if (list.getElemId) return list.getElemId(index);
      throw new RangeError(`Cannot find elemId at list index ${index}`);
    }
    module.exports = {
      Context
    };
  }
});

// node_modules/automerge/frontend/observable.js
var require_observable = __commonJS({
  "node_modules/automerge/frontend/observable.js"(exports, module) {
    var { OBJECT_ID, CONFLICTS } = require_constants();
    var Observable = class {
      constructor() {
        this.observers = {};
      }
      /**
       * Called by an Automerge document when `patch` is applied. `before` is the
       * state of the document before the patch, and `after` is the state after
       * applying it. `local` is true if the update is a result of locally calling
       * `Automerge.change()`, and false otherwise. `changes` is an array of
       * changes that were applied to the document (as Uint8Arrays).
       */
      patchCallback(patch, before, after, local, changes) {
        this._objectUpdate(patch.diffs, before, after, local, changes);
      }
      /**
       * Recursively walks a patch and calls the callbacks for all objects that
       * appear in the patch.
       */
      _objectUpdate(diff, before, after, local, changes) {
        if (!diff.objectId) return;
        if (this.observers[diff.objectId]) {
          for (let callback of this.observers[diff.objectId]) {
            callback(diff, before, after, local, changes);
          }
        }
        if (diff.type === "map" && diff.props) {
          for (const propName of Object.keys(diff.props)) {
            for (const opId of Object.keys(diff.props[propName])) {
              this._objectUpdate(
                diff.props[propName][opId],
                before && before[CONFLICTS] && before[CONFLICTS][propName] && before[CONFLICTS][propName][opId],
                after && after[CONFLICTS] && after[CONFLICTS][propName] && after[CONFLICTS][propName][opId],
                local,
                changes
              );
            }
          }
        } else if (diff.type === "table" && diff.props) {
          for (const rowId of Object.keys(diff.props)) {
            for (const opId of Object.keys(diff.props[rowId])) {
              this._objectUpdate(
                diff.props[rowId][opId],
                before && before.byId(rowId),
                after && after.byId(rowId),
                local,
                changes
              );
            }
          }
        } else if (diff.type === "list" && diff.edits) {
          let offset = 0;
          for (const edit of diff.edits) {
            if (edit.action === "insert") {
              offset -= 1;
              this._objectUpdate(
                edit.value,
                void 0,
                after && after[CONFLICTS] && after[CONFLICTS][edit.index] && after[CONFLICTS][edit.index][edit.elemId],
                local,
                changes
              );
            } else if (edit.action === "multi-insert") {
              offset -= edit.values.length;
            } else if (edit.action === "update") {
              this._objectUpdate(
                edit.value,
                before && before[CONFLICTS] && before[CONFLICTS][edit.index + offset] && before[CONFLICTS][edit.index + offset][edit.opId],
                after && after[CONFLICTS] && after[CONFLICTS][edit.index] && after[CONFLICTS][edit.index][edit.opId],
                local,
                changes
              );
            } else if (edit.action === "remove") {
              offset += edit.count;
            }
          }
        } else if (diff.type === "text" && diff.edits) {
          let offset = 0;
          for (const edit of diff.edits) {
            if (edit.action === "insert") {
              offset -= 1;
              this._objectUpdate(edit.value, void 0, after && after.get(edit.index), local, changes);
            } else if (edit.action === "multi-insert") {
              offset -= edit.values.length;
            } else if (edit.action === "update") {
              this._objectUpdate(
                edit.value,
                before && before.get(edit.index + offset),
                after && after.get(edit.index),
                local,
                changes
              );
            } else if (edit.action === "remove") {
              offset += edit.count;
            }
          }
        }
      }
      /**
       * Call this to register a callback that will get called whenever a particular
       * object in a document changes. The callback is passed five arguments: the
       * part of the patch describing the update to that object, the old state of
       * the object, the new state of the object, a boolean that is true if the
       * change is the result of calling `Automerge.change()` locally, and the array
       * of binary changes applied to the document.
       */
      observe(object, callback) {
        const objectId = object[OBJECT_ID];
        if (!objectId) throw new TypeError("The observed object must be part of an Automerge document");
        if (!this.observers[objectId]) this.observers[objectId] = [];
        this.observers[objectId].push(callback);
      }
    };
    module.exports = { Observable };
  }
});

// node_modules/automerge/frontend/index.js
var require_frontend = __commonJS({
  "node_modules/automerge/frontend/index.js"(exports, module) {
    var { OPTIONS, CACHE, STATE, OBJECT_ID, CONFLICTS, CHANGE, ELEM_IDS } = require_constants();
    var { isObject, copyObject } = require_common();
    var uuid = require_uuid2();
    var { interpretPatch, cloneRootObject } = require_apply_patch();
    var { rootObjectProxy } = require_proxies();
    var { Context } = require_context();
    var { Text } = require_text();
    var { Table } = require_table();
    var { Counter } = require_counter();
    var { Float64, Int, Uint } = require_numbers();
    var { Observable } = require_observable();
    function checkActorId(actorId) {
      if (typeof actorId !== "string") {
        throw new TypeError(`Unsupported type of actorId: ${typeof actorId}`);
      }
      if (!/^[0-9a-f]+$/.test(actorId)) {
        throw new RangeError("actorId must consist only of lowercase hex digits");
      }
      if (actorId.length % 2 !== 0) {
        throw new RangeError("actorId must consist of an even number of digits");
      }
    }
    function updateRootObject(doc, updated, state) {
      let newDoc = updated._root;
      if (!newDoc) {
        newDoc = cloneRootObject(doc[CACHE]._root);
        updated._root = newDoc;
      }
      Object.defineProperty(newDoc, OPTIONS, { value: doc[OPTIONS] });
      Object.defineProperty(newDoc, CACHE, { value: updated });
      Object.defineProperty(newDoc, STATE, { value: state });
      if (doc[OPTIONS].freeze) {
        for (let objectId of Object.keys(updated)) {
          if (updated[objectId] instanceof Table) {
            updated[objectId]._freeze();
          } else if (updated[objectId] instanceof Text) {
            Object.freeze(updated[objectId].elems);
            Object.freeze(updated[objectId]);
          } else {
            Object.freeze(updated[objectId]);
            Object.freeze(updated[objectId][CONFLICTS]);
          }
        }
      }
      for (let objectId of Object.keys(doc[CACHE])) {
        if (!updated[objectId]) {
          updated[objectId] = doc[CACHE][objectId];
        }
      }
      if (doc[OPTIONS].freeze) {
        Object.freeze(updated);
      }
      return newDoc;
    }
    function makeChange(doc, context, options) {
      const actor = getActorId(doc);
      if (!actor) {
        throw new Error("Actor ID must be initialized with setActorId() before making a change");
      }
      const state = copyObject(doc[STATE]);
      state.seq += 1;
      const change2 = {
        actor,
        seq: state.seq,
        startOp: state.maxOp + 1,
        deps: state.deps,
        time: options && typeof options.time === "number" ? options.time : Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3),
        message: options && typeof options.message === "string" ? options.message : "",
        ops: context.ops
      };
      if (doc[OPTIONS].backend) {
        const [backendState, patch, binaryChange] = doc[OPTIONS].backend.applyLocalChange(state.backendState, change2);
        state.backendState = backendState;
        state.lastLocalChange = binaryChange;
        const newDoc = applyPatchToDoc(doc, patch, state, true);
        const patchCallback = options && options.patchCallback || doc[OPTIONS].patchCallback;
        if (patchCallback) patchCallback(patch, doc, newDoc, true, [binaryChange]);
        return [newDoc, change2];
      } else {
        const queuedRequest = { actor, seq: change2.seq, before: doc };
        state.requests = state.requests.concat([queuedRequest]);
        state.maxOp = state.maxOp + countOps(change2.ops);
        state.deps = [];
        return [updateRootObject(doc, context ? context.updated : {}, state), change2];
      }
    }
    function countOps(ops) {
      let count = 0;
      for (const op of ops) {
        if (op.action === "set" && op.values) {
          count += op.values.length;
        } else {
          count += 1;
        }
      }
      return count;
    }
    function getLastLocalChange(doc) {
      return doc[STATE] && doc[STATE].lastLocalChange ? doc[STATE].lastLocalChange : null;
    }
    function applyPatchToDoc(doc, patch, state, fromBackend) {
      const actor = getActorId(doc);
      const updated = {};
      interpretPatch(patch.diffs, doc, updated);
      if (fromBackend) {
        if (!patch.clock) throw new RangeError("patch is missing clock field");
        if (patch.clock[actor] && patch.clock[actor] > state.seq) {
          state.seq = patch.clock[actor];
        }
        state.clock = patch.clock;
        state.deps = patch.deps;
        state.maxOp = Math.max(state.maxOp, patch.maxOp);
      }
      return updateRootObject(doc, updated, state);
    }
    function init(options) {
      if (typeof options === "string") {
        options = { actorId: options };
      } else if (typeof options === "undefined") {
        options = {};
      } else if (!isObject(options)) {
        throw new TypeError(`Unsupported value for init() options: ${options}`);
      }
      if (!options.deferActorId) {
        if (options.actorId === void 0) {
          options.actorId = uuid();
        }
        checkActorId(options.actorId);
      }
      if (options.observable) {
        const patchCallback = options.patchCallback, observable = options.observable;
        options.patchCallback = (patch, before, after, local, changes) => {
          if (patchCallback) patchCallback(patch, before, after, local, changes);
          observable.patchCallback(patch, before, after, local, changes);
        };
      }
      const root = {}, cache = { _root: root };
      const state = { seq: 0, maxOp: 0, requests: [], clock: {}, deps: [] };
      if (options.backend) {
        state.backendState = options.backend.init();
        state.lastLocalChange = null;
      }
      Object.defineProperty(root, OBJECT_ID, { value: "_root" });
      Object.defineProperty(root, OPTIONS, { value: Object.freeze(options) });
      Object.defineProperty(root, CONFLICTS, { value: Object.freeze({}) });
      Object.defineProperty(root, CACHE, { value: Object.freeze(cache) });
      Object.defineProperty(root, STATE, { value: Object.freeze(state) });
      return Object.freeze(root);
    }
    function from(initialState, options) {
      return change(init(options), "Initialization", (doc) => Object.assign(doc, initialState));
    }
    function change(doc, options, callback) {
      if (doc[OBJECT_ID] !== "_root") {
        throw new TypeError("The first argument to Automerge.change must be the document root");
      }
      if (doc[CHANGE]) {
        throw new TypeError("Calls to Automerge.change cannot be nested");
      }
      if (typeof options === "function" && callback === void 0) {
        [options, callback] = [callback, options];
      }
      if (typeof options === "string") {
        options = { message: options };
      }
      if (options !== void 0 && !isObject(options)) {
        throw new TypeError("Unsupported type of options");
      }
      const actorId = getActorId(doc);
      if (!actorId) {
        throw new Error("Actor ID must be initialized with setActorId() before making a change");
      }
      const context = new Context(doc, actorId);
      callback(rootObjectProxy(context));
      if (Object.keys(context.updated).length === 0) {
        return [doc, null];
      } else {
        return makeChange(doc, context, options);
      }
    }
    function emptyChange(doc, options) {
      if (doc[OBJECT_ID] !== "_root") {
        throw new TypeError("The first argument to Automerge.emptyChange must be the document root");
      }
      if (typeof options === "string") {
        options = { message: options };
      }
      if (options !== void 0 && !isObject(options)) {
        throw new TypeError("Unsupported type of options");
      }
      const actorId = getActorId(doc);
      if (!actorId) {
        throw new Error("Actor ID must be initialized with setActorId() before making a change");
      }
      return makeChange(doc, new Context(doc, actorId), options);
    }
    function applyPatch(doc, patch, backendState = void 0) {
      if (doc[OBJECT_ID] !== "_root") {
        throw new TypeError("The first argument to Frontend.applyPatch must be the document root");
      }
      const state = copyObject(doc[STATE]);
      if (doc[OPTIONS].backend) {
        if (!backendState) {
          throw new RangeError("applyPatch must be called with the updated backend state");
        }
        state.backendState = backendState;
        return applyPatchToDoc(doc, patch, state, true);
      }
      let baseDoc;
      if (state.requests.length > 0) {
        baseDoc = state.requests[0].before;
        if (patch.actor === getActorId(doc)) {
          if (state.requests[0].seq !== patch.seq) {
            throw new RangeError(`Mismatched sequence number: patch ${patch.seq} does not match next request ${state.requests[0].seq}`);
          }
          state.requests = state.requests.slice(1);
        } else {
          state.requests = state.requests.slice();
        }
      } else {
        baseDoc = doc;
        state.requests = [];
      }
      let newDoc = applyPatchToDoc(baseDoc, patch, state, true);
      if (state.requests.length === 0) {
        return newDoc;
      } else {
        state.requests[0] = copyObject(state.requests[0]);
        state.requests[0].before = newDoc;
        return updateRootObject(doc, {}, state);
      }
    }
    function getObjectId(object) {
      return object[OBJECT_ID];
    }
    function getObjectById(doc, objectId) {
      if (doc[CHANGE]) {
        throw new TypeError("Cannot use getObjectById in a change callback");
      }
      return doc[CACHE][objectId];
    }
    function getActorId(doc) {
      return doc[STATE].actorId || doc[OPTIONS].actorId;
    }
    function setActorId(doc, actorId) {
      checkActorId(actorId);
      const state = Object.assign({}, doc[STATE], { actorId });
      return updateRootObject(doc, {}, state);
    }
    function getConflicts(object, key) {
      if (object[CONFLICTS] && object[CONFLICTS][key] && Object.keys(object[CONFLICTS][key]).length > 1) {
        return object[CONFLICTS][key];
      }
    }
    function getBackendState(doc, callerName = null, argPos = "first") {
      if (doc[OBJECT_ID] !== "_root") {
        const extraMsg = Array.isArray(doc) ? ". Note: Automerge.applyChanges now returns an array." : "";
        if (callerName) {
          throw new TypeError(`The ${argPos} argument to Automerge.${callerName} must be the document root${extraMsg}`);
        } else {
          throw new TypeError(`Argument is not an Automerge document root${extraMsg}`);
        }
      }
      return doc[STATE].backendState;
    }
    function getElementIds(list) {
      if (list instanceof Text) {
        return list.elems.map((elem) => elem.elemId);
      } else {
        return list[ELEM_IDS];
      }
    }
    module.exports = {
      init,
      from,
      change,
      emptyChange,
      applyPatch,
      getObjectId,
      getObjectById,
      getActorId,
      setActorId,
      getConflicts,
      getLastLocalChange,
      getBackendState,
      getElementIds,
      Text,
      Table,
      Counter,
      Observable,
      Float64,
      Int,
      Uint
    };
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports, module) {
    "use strict";
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
    );
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    var send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    var send_code = (s, c, tree) => {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    };
    var bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m;
      let bits;
      let xbits;
      let f;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    };
    var init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.sym_next = s.matches = 0;
    };
    var bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    var smaller = (tree, n, m, depth) => {
      const _n2 = n * 2;
      const _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    var pqdownheap = (s, tree, k) => {
      const v = s.heap[k];
      let j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    };
    var compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let sx = 0;
      let code;
      let extra;
      if (s.sym_next !== 0) {
        do {
          dist = s.pending_buf[s.sym_buf + sx++] & 255;
          dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
          lc = s.pending_buf[s.sym_buf + sx++];
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (sx < s.sym_next);
      }
      send_code(s, END_BLOCK, ltree);
    };
    var build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    var scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    var _tr_stored_block = (s, buf, stored_len, last) => {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      bi_windup(s);
      put_short(s, stored_len);
      put_short(s, ~stored_len);
      if (stored_len) {
        s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
      }
      s.pending += stored_len;
    };
    var _tr_align = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    var _tr_flush_block = (s, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    };
    var _tr_tally = (s, dist, lc) => {
      s.pending_buf[s.sym_buf + s.sym_next++] = dist;
      s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
      s.pending_buf[s.sym_buf + s.sym_next++] = lc;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.sym_next === s.sym_end;
    };
    module.exports._tr_init = _tr_init;
    module.exports._tr_stored_block = _tr_stored_block;
    module.exports._tr_flush_block = _tr_flush_block;
    module.exports._tr_tally = _tr_tally;
    module.exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    var makeTable = () => {
      let c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants2 = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports, module) {
    "use strict";
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var {
      Z_NO_FLUSH,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_BLOCK,
      Z_OK,
      Z_STREAM_END,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY,
      Z_UNKNOWN,
      Z_DEFLATED
    } = require_constants2();
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var GZIP_STATE = 57;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = msg[errorCode];
      return errorCode;
    };
    var rank = (f) => {
      return f * 2 - (f > 4 ? 9 : 0);
    };
    var zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var slide_hash = (s) => {
      let n, m;
      let p;
      let wsize = s.w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
      n = wsize;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
    };
    var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    var flush_block_only = (s, last) => {
      _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    var put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    var putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    var read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    var fill_window = (s) => {
      const _w_size = s.w_size;
      let n, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
          slide_hash(s);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    var deflate_stored = (s, flush) => {
      let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
      let len, left, have, last = 0;
      let used = s.strm.avail_in;
      do {
        len = 65535;
        have = s.bi_valid + 42 >> 3;
        if (s.strm.avail_out < have) {
          break;
        }
        have = s.strm.avail_out - have;
        left = s.strstart - s.block_start;
        if (len > left + s.strm.avail_in) {
          len = left + s.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in)) {
          break;
        }
        last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
        _tr_stored_block(s, 0, 0, last);
        s.pending_buf[s.pending - 4] = len;
        s.pending_buf[s.pending - 3] = len >> 8;
        s.pending_buf[s.pending - 2] = ~len;
        s.pending_buf[s.pending - 1] = ~len >> 8;
        flush_pending(s.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
          s.strm.next_out += left;
          s.strm.avail_out -= left;
          s.strm.total_out += left;
          s.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf(s.strm, s.strm.output, s.strm.next_out, len);
          s.strm.next_out += len;
          s.strm.avail_out -= len;
          s.strm.total_out += len;
        }
      } while (last === 0);
      used -= s.strm.avail_in;
      if (used) {
        if (used >= s.w_size) {
          s.matches = 2;
          s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
          s.strstart = s.w_size;
          s.insert = s.strstart;
        } else {
          if (s.window_size - s.strstart <= used) {
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
              s.matches++;
            }
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
          }
          s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
          s.strstart += used;
          s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
        }
        s.block_start = s.strstart;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      if (last) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH && flush !== Z_FINISH && s.strm.avail_in === 0 && s.strstart === s.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s.window_size - s.strstart;
      if (s.strm.avail_in > have && s.block_start >= s.w_size) {
        s.block_start -= s.w_size;
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        have += s.w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      if (have > s.strm.avail_in) {
        have = s.strm.avail_in;
      }
      if (have) {
        read_buf(s.strm, s.window, s.strstart, have);
        s.strstart += have;
        s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      have = s.bi_valid + 42 >> 3;
      have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
      min_block = have > s.w_size ? s.w_size : have;
      left = s.strstart - s.block_start;
      if (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && s.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last = flush === Z_FINISH && s.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s, s.block_start, len, last);
        s.block_start += len;
        flush_pending(s.strm);
      }
      return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    var deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s, flush) => {
      let bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    var lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero(this.depth);
      this.sym_buf = 0;
      this.lit_bufsize = 0;
      this.sym_next = 0;
      this.sym_end = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s = strm.state;
      if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
      s.status !== GZIP_STATE && //#endif
      s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    var deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = //#ifdef GZIP
      s.wrap === 2 ? GZIP_STATE : (
        //#endif
        s.wrap ? INIT_STATE : BUSY_STATE
      );
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = -2;
      _tr_init(s);
      return Z_OK;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    };
    var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.status = INIT_STATE;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.sym_buf = s.lit_bufsize;
      s.sym_end = (s.lit_bufsize - 1) * 3;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      const s = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === INIT_STATE && s.wrap === 0) {
        s.status = BUSY_STATE;
      }
      if (s.status === INIT_STATE) {
        let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (s.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          let beg = s.pending;
          let left = (s.gzhead.extra.length & 65535) - s.gzindex;
          while (s.pending + left > s.pending_buf_size) {
            let copy = s.pending_buf_size - s.pending;
            s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
            s.pending = s.pending_buf_size;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex += copy;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
            beg = 0;
            left -= copy;
          }
          let gzhead_extra = new Uint8Array(s.gzhead.extra);
          s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
          s.pending += left;
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = NAME_STATE;
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = COMMENT_STATE;
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
        }
        s.status = HCRC_STATE;
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const s = strm.state;
      const wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    };
    module.exports.deflateInit = deflateInit;
    module.exports.deflateInit2 = deflateInit2;
    module.exports.deflateReset = deflateReset;
    module.exports.deflateResetKeep = deflateResetKeep;
    module.exports.deflateSetHeader = deflateSetHeader;
    module.exports.deflate = deflate;
    module.exports.deflateEnd = deflateEnd;
    module.exports.deflateSetDictionary = deflateSetDictionary;
    module.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/common.js
var require_common2 = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports, module) {
    "use strict";
    var _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    module.exports.assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    module.exports.flattenChunks = (chunks) => {
      let len = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports, module) {
    "use strict";
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    module.exports.string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    module.exports.buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    module.exports.utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports, module) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common2();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED
    } = require_constants2();
    function Deflate(options) {
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = zlib_deflate.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        this.result = utils.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      const deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.constants = require_constants2();
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 16209;
    var TYPE = 16191;
    module.exports = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        match = 20;
      } else if (type === LENS) {
        base = lbase;
        extra = lext;
        match = 257;
      } else {
        base = dbase;
        extra = dext;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    module.exports = inflate_table;
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports, module) {
    "use strict";
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH,
      Z_BLOCK,
      Z_TREES,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = require_constants2();
    var HEAD = 16180;
    var FLAGS = 16181;
    var TIME = 16182;
    var OS = 16183;
    var EXLEN = 16184;
    var EXTRA = 16185;
    var NAME = 16186;
    var COMMENT = 16187;
    var HCRC = 16188;
    var DICTID = 16189;
    var DICT = 16190;
    var TYPE = 16191;
    var TYPEDO = 16192;
    var STORED = 16193;
    var COPY_ = 16194;
    var COPY = 16195;
    var TABLE = 16196;
    var LENLENS = 16197;
    var CODELENS = 16198;
    var LEN_ = 16199;
    var LEN = 16200;
    var LENEXT = 16201;
    var DIST = 16202;
    var DISTEXT = 16203;
    var MATCH = 16204;
    var LIT = 16205;
    var CHECK = 16206;
    var LENGTH = 16207;
    var DONE = 16208;
    var BAD = 16209;
    var MEM = 16210;
    var SYNC = 16211;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    function InflateState() {
      this.strm = null;
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    var inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    };
    var inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              }
              if (len > 15 || len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    };
    var inflateGetHeader = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    };
    module.exports.inflateReset = inflateReset;
    module.exports.inflateReset2 = inflateReset2;
    module.exports.inflateResetKeep = inflateResetKeep;
    module.exports.inflateInit = inflateInit;
    module.exports.inflateInit2 = inflateInit2;
    module.exports.inflate = inflate;
    module.exports.inflateEnd = inflateEnd;
    module.exports.inflateGetHeader = inflateGetHeader;
    module.exports.inflateSetDictionary = inflateSetDictionary;
    module.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports, module) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common2();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = require_constants2();
    function Inflate(options) {
      this.options = utils.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended) return false;
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = zlib_inflate.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          zlib_inflate.inflateReset(strm);
          status = zlib_inflate.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0) continue;
        if (status === Z_STREAM_END) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      const inflator = new Inflate(options);
      inflator.push(input);
      if (inflator.err) throw inflator.msg || msg[inflator.err];
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = inflate;
    module.exports.constants = require_constants2();
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module) {
    "use strict";
    var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
    var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
    var constants = require_constants2();
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = ungzip;
    module.exports.constants = constants;
  }
});

// node_modules/automerge/backend/encoding.js
var require_encoding = __commonJS({
  "node_modules/automerge/backend/encoding.js"(exports, module) {
    var utf8encoder = new TextEncoder();
    var utf8decoder = new TextDecoder("utf-8");
    function stringToUtf8(string) {
      return utf8encoder.encode(string);
    }
    function utf8ToString(buffer) {
      return utf8decoder.decode(buffer);
    }
    function hexStringToBytes(value) {
      if (typeof value !== "string") {
        throw new TypeError("value is not a string");
      }
      if (!/^([0-9a-f][0-9a-f])*$/.test(value)) {
        throw new RangeError("value is not hexadecimal");
      }
      if (value === "") {
        return new Uint8Array(0);
      } else {
        return new Uint8Array(value.match(/../g).map((b) => parseInt(b, 16)));
      }
    }
    var NIBBLE_TO_HEX = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    var BYTE_TO_HEX = new Array(256);
    for (let i = 0; i < 256; i++) {
      BYTE_TO_HEX[i] = `${NIBBLE_TO_HEX[i >>> 4 & 15]}${NIBBLE_TO_HEX[i & 15]}`;
    }
    function bytesToHexString(bytes) {
      let hex = "", len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        hex += BYTE_TO_HEX[bytes[i]];
      }
      return hex;
    }
    var Encoder = class {
      constructor() {
        this.buf = new Uint8Array(16);
        this.offset = 0;
      }
      /**
       * Returns the byte array containing the encoded data.
       */
      get buffer() {
        this.finish();
        return this.buf.subarray(0, this.offset);
      }
      /**
       * Reallocates the encoder's buffer to be bigger.
       */
      grow(minSize = 0) {
        let newSize = this.buf.byteLength * 4;
        while (newSize < minSize) newSize *= 2;
        const newBuf = new Uint8Array(newSize);
        newBuf.set(this.buf, 0);
        this.buf = newBuf;
        return this;
      }
      /**
       * Appends one byte (0 to 255) to the buffer.
       */
      appendByte(value) {
        if (this.offset >= this.buf.byteLength) this.grow();
        this.buf[this.offset] = value;
        this.offset += 1;
      }
      /**
       * Encodes a 32-bit nonnegative integer in a variable number of bytes using
       * the LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and
       * appends it to the buffer. Returns the number of bytes written.
       */
      appendUint32(value) {
        if (!Number.isInteger(value)) throw new RangeError("value is not an integer");
        if (value < 0 || value > 4294967295) throw new RangeError("number out of range");
        const numBytes = Math.max(1, Math.ceil((32 - Math.clz32(value)) / 7));
        if (this.offset + numBytes > this.buf.byteLength) this.grow();
        for (let i = 0; i < numBytes; i++) {
          this.buf[this.offset + i] = value & 127 | (i === numBytes - 1 ? 0 : 128);
          value >>>= 7;
        }
        this.offset += numBytes;
        return numBytes;
      }
      /**
       * Encodes a 32-bit signed integer in a variable number of bytes using the
       * LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and appends
       * it to the buffer. Returns the number of bytes written.
       */
      appendInt32(value) {
        if (!Number.isInteger(value)) throw new RangeError("value is not an integer");
        if (value < -2147483648 || value > 2147483647) throw new RangeError("number out of range");
        const numBytes = Math.ceil((33 - Math.clz32(value >= 0 ? value : -value - 1)) / 7);
        if (this.offset + numBytes > this.buf.byteLength) this.grow();
        for (let i = 0; i < numBytes; i++) {
          this.buf[this.offset + i] = value & 127 | (i === numBytes - 1 ? 0 : 128);
          value >>= 7;
        }
        this.offset += numBytes;
        return numBytes;
      }
      /**
       * Encodes a nonnegative integer in a variable number of bytes using the LEB128
       * encoding scheme, up to the maximum size of integers supported by JavaScript
       * (53 bits).
       */
      appendUint53(value) {
        if (!Number.isInteger(value)) throw new RangeError("value is not an integer");
        if (value < 0 || value > Number.MAX_SAFE_INTEGER) {
          throw new RangeError("number out of range");
        }
        const high32 = Math.floor(value / 4294967296);
        const low32 = (value & 4294967295) >>> 0;
        return this.appendUint64(high32, low32);
      }
      /**
       * Encodes a signed integer in a variable number of bytes using the LEB128
       * encoding scheme, up to the maximum size of integers supported by JavaScript
       * (53 bits).
       */
      appendInt53(value) {
        if (!Number.isInteger(value)) throw new RangeError("value is not an integer");
        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {
          throw new RangeError("number out of range");
        }
        const high32 = Math.floor(value / 4294967296);
        const low32 = (value & 4294967295) >>> 0;
        return this.appendInt64(high32, low32);
      }
      /**
       * Encodes a 64-bit nonnegative integer in a variable number of bytes using
       * the LEB128 encoding scheme, and appends it to the buffer. The number is
       * given as two 32-bit halves since JavaScript cannot accurately represent
       * integers with more than 53 bits in a single variable.
       */
      appendUint64(high32, low32) {
        if (!Number.isInteger(high32) || !Number.isInteger(low32)) {
          throw new RangeError("value is not an integer");
        }
        if (high32 < 0 || high32 > 4294967295 || low32 < 0 || low32 > 4294967295) {
          throw new RangeError("number out of range");
        }
        if (high32 === 0) return this.appendUint32(low32);
        const numBytes = Math.ceil((64 - Math.clz32(high32)) / 7);
        if (this.offset + numBytes > this.buf.byteLength) this.grow();
        for (let i = 0; i < 4; i++) {
          this.buf[this.offset + i] = low32 & 127 | 128;
          low32 >>>= 7;
        }
        this.buf[this.offset + 4] = low32 & 15 | (high32 & 7) << 4 | (numBytes === 5 ? 0 : 128);
        high32 >>>= 3;
        for (let i = 5; i < numBytes; i++) {
          this.buf[this.offset + i] = high32 & 127 | (i === numBytes - 1 ? 0 : 128);
          high32 >>>= 7;
        }
        this.offset += numBytes;
        return numBytes;
      }
      /**
       * Encodes a 64-bit signed integer in a variable number of bytes using the
       * LEB128 encoding scheme, and appends it to the buffer. The number is given
       * as two 32-bit halves since JavaScript cannot accurately represent integers
       * with more than 53 bits in a single variable. The sign of the 64-bit
       * number is determined by the sign of the `high32` half; the sign of the
       * `low32` half is ignored.
       */
      appendInt64(high32, low32) {
        if (!Number.isInteger(high32) || !Number.isInteger(low32)) {
          throw new RangeError("value is not an integer");
        }
        if (high32 < -2147483648 || high32 > 2147483647 || low32 < -2147483648 || low32 > 4294967295) {
          throw new RangeError("number out of range");
        }
        low32 >>>= 0;
        if (high32 === 0 && low32 <= 2147483647) return this.appendInt32(low32);
        if (high32 === -1 && low32 >= 2147483648) return this.appendInt32(low32 - 4294967296);
        const numBytes = Math.ceil((65 - Math.clz32(high32 >= 0 ? high32 : -high32 - 1)) / 7);
        if (this.offset + numBytes > this.buf.byteLength) this.grow();
        for (let i = 0; i < 4; i++) {
          this.buf[this.offset + i] = low32 & 127 | 128;
          low32 >>>= 7;
        }
        this.buf[this.offset + 4] = low32 & 15 | (high32 & 7) << 4 | (numBytes === 5 ? 0 : 128);
        high32 >>= 3;
        for (let i = 5; i < numBytes; i++) {
          this.buf[this.offset + i] = high32 & 127 | (i === numBytes - 1 ? 0 : 128);
          high32 >>= 7;
        }
        this.offset += numBytes;
        return numBytes;
      }
      /**
       * Appends the contents of byte buffer `data` to the buffer. Returns the
       * number of bytes appended.
       */
      appendRawBytes(data) {
        if (this.offset + data.byteLength > this.buf.byteLength) {
          this.grow(this.offset + data.byteLength);
        }
        this.buf.set(data, this.offset);
        this.offset += data.byteLength;
        return data.byteLength;
      }
      /**
       * Appends a UTF-8 string to the buffer, without any metadata. Returns the
       * number of bytes appended.
       */
      appendRawString(value) {
        if (typeof value !== "string") throw new TypeError("value is not a string");
        return this.appendRawBytes(stringToUtf8(value));
      }
      /**
       * Appends the contents of byte buffer `data` to the buffer, prefixed with the
       * number of bytes in the buffer (as a LEB128-encoded unsigned integer).
       */
      appendPrefixedBytes(data) {
        this.appendUint53(data.byteLength);
        this.appendRawBytes(data);
        return this;
      }
      /**
       * Appends a UTF-8 string to the buffer, prefixed with its length in bytes
       * (where the length is encoded as an unsigned LEB128 integer).
       */
      appendPrefixedString(value) {
        if (typeof value !== "string") throw new TypeError("value is not a string");
        this.appendPrefixedBytes(stringToUtf8(value));
        return this;
      }
      /**
       * Takes a value, which must be a string consisting only of hexadecimal
       * digits, maps it to a byte array, and appends it to the buffer, prefixed
       * with its length in bytes.
       */
      appendHexString(value) {
        this.appendPrefixedBytes(hexStringToBytes(value));
        return this;
      }
      /**
       * Flushes any unwritten data to the buffer. Call this before reading from
       * the buffer constructed by this Encoder.
       */
      finish() {
      }
    };
    var Decoder = class {
      constructor(buffer) {
        if (!(buffer instanceof Uint8Array)) {
          throw new TypeError(`Not a byte array: ${buffer}`);
        }
        this.buf = buffer;
        this.offset = 0;
      }
      /**
       * Returns false if there is still data to be read at the current decoding
       * position, and true if we are at the end of the buffer.
       */
      get done() {
        return this.offset === this.buf.byteLength;
      }
      /**
       * Resets the cursor position, so that the next read goes back to the
       * beginning of the buffer.
       */
      reset() {
        this.offset = 0;
      }
      /**
       * Moves the current decoding position forward by the specified number of
       * bytes, without decoding anything.
       */
      skip(bytes) {
        if (this.offset + bytes > this.buf.byteLength) {
          throw new RangeError("cannot skip beyond end of buffer");
        }
        this.offset += bytes;
      }
      /**
       * Reads one byte (0 to 255) from the buffer.
       */
      readByte() {
        this.offset += 1;
        return this.buf[this.offset - 1];
      }
      /**
       * Reads a LEB128-encoded unsigned integer from the current position in the buffer.
       * Throws an exception if the value doesn't fit in a 32-bit unsigned int.
       */
      readUint32() {
        let result = 0, shift = 0;
        while (this.offset < this.buf.byteLength) {
          const nextByte = this.buf[this.offset];
          if (shift === 28 && (nextByte & 240) !== 0) {
            throw new RangeError("number out of range");
          }
          result = (result | (nextByte & 127) << shift) >>> 0;
          shift += 7;
          this.offset++;
          if ((nextByte & 128) === 0) return result;
        }
        throw new RangeError("buffer ended with incomplete number");
      }
      /**
       * Reads a LEB128-encoded signed integer from the current position in the buffer.
       * Throws an exception if the value doesn't fit in a 32-bit signed int.
       */
      readInt32() {
        let result = 0, shift = 0;
        while (this.offset < this.buf.byteLength) {
          const nextByte = this.buf[this.offset];
          if (shift === 28 && (nextByte & 128) !== 0 || // more than 5 bytes
          shift === 28 && (nextByte & 64) === 0 && (nextByte & 56) !== 0 || // positive int > 0x7fffffff
          shift === 28 && (nextByte & 64) !== 0 && (nextByte & 56) !== 56) {
            throw new RangeError("number out of range");
          }
          result |= (nextByte & 127) << shift;
          shift += 7;
          this.offset++;
          if ((nextByte & 128) === 0) {
            if ((nextByte & 64) === 0 || shift > 28) {
              return result;
            } else {
              return result | -1 << shift;
            }
          }
        }
        throw new RangeError("buffer ended with incomplete number");
      }
      /**
       * Reads a LEB128-encoded unsigned integer from the current position in the
       * buffer. Allows any integer that can be safely represented by JavaScript
       * (up to 2^53 - 1), and throws an exception outside of that range.
       */
      readUint53() {
        const { low32, high32 } = this.readUint64();
        if (high32 < 0 || high32 > 2097151) {
          throw new RangeError("number out of range");
        }
        return high32 * 4294967296 + low32;
      }
      /**
       * Reads a LEB128-encoded signed integer from the current position in the
       * buffer. Allows any integer that can be safely represented by JavaScript
       * (between -(2^53 - 1) and 2^53 - 1), throws an exception outside of that range.
       */
      readInt53() {
        const { low32, high32 } = this.readInt64();
        if (high32 < -2097152 || high32 === -2097152 && low32 === 0 || high32 > 2097151) {
          throw new RangeError("number out of range");
        }
        return high32 * 4294967296 + low32;
      }
      /**
       * Reads a LEB128-encoded unsigned integer from the current position in the
       * buffer. Throws an exception if the value doesn't fit in a 64-bit unsigned
       * int. Returns the number in two 32-bit halves, as an object of the form
       * `{high32, low32}`.
       */
      readUint64() {
        let low32 = 0, high32 = 0, shift = 0;
        while (this.offset < this.buf.byteLength && shift <= 28) {
          const nextByte = this.buf[this.offset];
          low32 = (low32 | (nextByte & 127) << shift) >>> 0;
          if (shift === 28) {
            high32 = (nextByte & 112) >>> 4;
          }
          shift += 7;
          this.offset++;
          if ((nextByte & 128) === 0) return { high32, low32 };
        }
        shift = 3;
        while (this.offset < this.buf.byteLength) {
          const nextByte = this.buf[this.offset];
          if (shift === 31 && (nextByte & 254) !== 0) {
            throw new RangeError("number out of range");
          }
          high32 = (high32 | (nextByte & 127) << shift) >>> 0;
          shift += 7;
          this.offset++;
          if ((nextByte & 128) === 0) return { high32, low32 };
        }
        throw new RangeError("buffer ended with incomplete number");
      }
      /**
       * Reads a LEB128-encoded signed integer from the current position in the
       * buffer. Throws an exception if the value doesn't fit in a 64-bit signed
       * int. Returns the number in two 32-bit halves, as an object of the form
       * `{high32, low32}`. The `low32` half is always non-negative, and the
       * sign of the `high32` half indicates the sign of the 64-bit number.
       */
      readInt64() {
        let low32 = 0, high32 = 0, shift = 0;
        while (this.offset < this.buf.byteLength && shift <= 28) {
          const nextByte = this.buf[this.offset];
          low32 = (low32 | (nextByte & 127) << shift) >>> 0;
          if (shift === 28) {
            high32 = (nextByte & 112) >>> 4;
          }
          shift += 7;
          this.offset++;
          if ((nextByte & 128) === 0) {
            if ((nextByte & 64) !== 0) {
              if (shift < 32) low32 = (low32 | -1 << shift) >>> 0;
              high32 |= -1 << Math.max(shift - 32, 0);
            }
            return { high32, low32 };
          }
        }
        shift = 3;
        while (this.offset < this.buf.byteLength) {
          const nextByte = this.buf[this.offset];
          if (shift === 31 && nextByte !== 0 && nextByte !== 127) {
            throw new RangeError("number out of range");
          }
          high32 |= (nextByte & 127) << shift;
          shift += 7;
          this.offset++;
          if ((nextByte & 128) === 0) {
            if ((nextByte & 64) !== 0 && shift < 32) {
              high32 |= -1 << shift;
            }
            return { high32, low32 };
          }
        }
        throw new RangeError("buffer ended with incomplete number");
      }
      /**
       * Extracts a subarray `length` bytes in size, starting from the current
       * position in the buffer, and moves the position forward.
       */
      readRawBytes(length) {
        const start = this.offset;
        if (start + length > this.buf.byteLength) {
          throw new RangeError("subarray exceeds buffer size");
        }
        this.offset += length;
        return this.buf.subarray(start, this.offset);
      }
      /**
       * Extracts `length` bytes from the buffer, starting from the current position,
       * and returns the UTF-8 string decoding of those bytes.
       */
      readRawString(length) {
        return utf8ToString(this.readRawBytes(length));
      }
      /**
       * Extracts a subarray from the current position in the buffer, prefixed with
       * its length in bytes (encoded as an unsigned LEB128 integer).
       */
      readPrefixedBytes() {
        return this.readRawBytes(this.readUint53());
      }
      /**
       * Reads a UTF-8 string from the current position in the buffer, prefixed with its
       * length in bytes (where the length is encoded as an unsigned LEB128 integer).
       */
      readPrefixedString() {
        return utf8ToString(this.readPrefixedBytes());
      }
      /**
       * Reads a byte array from the current position in the buffer, prefixed with its
       * length in bytes. Returns that byte array converted to a hexadecimal string.
       */
      readHexString() {
        return bytesToHexString(this.readPrefixedBytes());
      }
    };
    var RLEEncoder = class extends Encoder {
      constructor(type) {
        super();
        this.type = type;
        this.state = "empty";
        this.lastValue = void 0;
        this.count = 0;
        this.literal = [];
      }
      /**
       * Appends a new value to the sequence. If `repetitions` is given, the value is repeated
       * `repetitions` times.
       */
      appendValue(value, repetitions = 1) {
        this._appendValue(value, repetitions);
      }
      /**
       * Like `appendValue()`, but this method is not overridden by `DeltaEncoder`.
       */
      _appendValue(value, repetitions = 1) {
        if (repetitions <= 0) return;
        if (this.state === "empty") {
          this.state = value === null ? "nulls" : repetitions === 1 ? "loneValue" : "repetition";
          this.lastValue = value;
          this.count = repetitions;
        } else if (this.state === "loneValue") {
          if (value === null) {
            this.flush();
            this.state = "nulls";
            this.count = repetitions;
          } else if (value === this.lastValue) {
            this.state = "repetition";
            this.count = 1 + repetitions;
          } else if (repetitions > 1) {
            this.flush();
            this.state = "repetition";
            this.count = repetitions;
            this.lastValue = value;
          } else {
            this.state = "literal";
            this.literal = [this.lastValue];
            this.lastValue = value;
          }
        } else if (this.state === "repetition") {
          if (value === null) {
            this.flush();
            this.state = "nulls";
            this.count = repetitions;
          } else if (value === this.lastValue) {
            this.count += repetitions;
          } else if (repetitions > 1) {
            this.flush();
            this.state = "repetition";
            this.count = repetitions;
            this.lastValue = value;
          } else {
            this.flush();
            this.state = "loneValue";
            this.lastValue = value;
          }
        } else if (this.state === "literal") {
          if (value === null) {
            this.literal.push(this.lastValue);
            this.flush();
            this.state = "nulls";
            this.count = repetitions;
          } else if (value === this.lastValue) {
            this.flush();
            this.state = "repetition";
            this.count = 1 + repetitions;
          } else if (repetitions > 1) {
            this.literal.push(this.lastValue);
            this.flush();
            this.state = "repetition";
            this.count = repetitions;
            this.lastValue = value;
          } else {
            this.literal.push(this.lastValue);
            this.lastValue = value;
          }
        } else if (this.state === "nulls") {
          if (value === null) {
            this.count += repetitions;
          } else if (repetitions > 1) {
            this.flush();
            this.state = "repetition";
            this.count = repetitions;
            this.lastValue = value;
          } else {
            this.flush();
            this.state = "loneValue";
            this.lastValue = value;
          }
        }
      }
      /**
       * Copies values from the RLEDecoder `decoder` into this encoder. The `options` object may
       * contain the following keys:
       *  - `count`: The number of values to copy. If not specified, copies all remaining values.
       *  - `sumValues`: If true, the function computes the sum of all numeric values as they are
       *    copied (null values are counted as zero), and returns that number.
       *  - `sumShift`: If set, values are shifted right by `sumShift` bits before adding to the sum.
       *
       * Returns an object of the form `{nonNullValues, sum}` where `nonNullValues` is the number of
       * non-null values copied, and `sum` is the sum (only if the `sumValues` option is set).
       */
      copyFrom(decoder, options = {}) {
        const { count, sumValues, sumShift } = options;
        if (!(decoder instanceof RLEDecoder) || decoder.type !== this.type) {
          throw new TypeError("incompatible type of decoder");
        }
        let remaining = typeof count === "number" ? count : Number.MAX_SAFE_INTEGER;
        let nonNullValues = 0, sum = 0;
        if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);
        if (remaining === 0 || decoder.done) return sumValues ? { nonNullValues, sum } : { nonNullValues };
        let firstValue = decoder.readValue();
        if (firstValue === null) {
          const numNulls = Math.min(decoder.count + 1, remaining);
          remaining -= numNulls;
          decoder.count -= numNulls - 1;
          this.appendValue(null, numNulls);
          if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);
          if (remaining === 0 || decoder.done) return sumValues ? { nonNullValues, sum } : { nonNullValues };
          firstValue = decoder.readValue();
          if (firstValue === null) throw new RangeError("null run must be followed by non-null value");
        }
        this.appendValue(firstValue);
        remaining--;
        nonNullValues++;
        if (sumValues) sum += sumShift ? firstValue >>> sumShift : firstValue;
        if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);
        if (remaining === 0 || decoder.done) return sumValues ? { nonNullValues, sum } : { nonNullValues };
        let firstRun = decoder.count > 0;
        while (remaining > 0 && !decoder.done) {
          if (!firstRun) decoder.readRecord();
          const numValues = Math.min(decoder.count, remaining);
          decoder.count -= numValues;
          if (decoder.state === "literal") {
            nonNullValues += numValues;
            for (let i = 0; i < numValues; i++) {
              if (decoder.done) throw new RangeError("incomplete literal");
              const value = decoder.readRawValue();
              if (value === decoder.lastValue) throw new RangeError("Repetition of values is not allowed in literal");
              decoder.lastValue = value;
              this._appendValue(value);
              if (sumValues) sum += sumShift ? value >>> sumShift : value;
            }
          } else if (decoder.state === "repetition") {
            nonNullValues += numValues;
            if (sumValues) sum += numValues * (sumShift ? decoder.lastValue >>> sumShift : decoder.lastValue);
            const value = decoder.lastValue;
            this._appendValue(value);
            if (numValues > 1) {
              this._appendValue(value);
              if (this.state !== "repetition") throw new RangeError(`Unexpected state ${this.state}`);
              this.count += numValues - 2;
            }
          } else if (decoder.state === "nulls") {
            this._appendValue(null);
            if (this.state !== "nulls") throw new RangeError(`Unexpected state ${this.state}`);
            this.count += numValues - 1;
          }
          firstRun = false;
          remaining -= numValues;
        }
        if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);
        return sumValues ? { nonNullValues, sum } : { nonNullValues };
      }
      /**
       * Private method, do not call from outside the class.
       */
      flush() {
        if (this.state === "loneValue") {
          this.appendInt32(-1);
          this.appendRawValue(this.lastValue);
        } else if (this.state === "repetition") {
          this.appendInt53(this.count);
          this.appendRawValue(this.lastValue);
        } else if (this.state === "literal") {
          this.appendInt53(-this.literal.length);
          for (let v of this.literal) this.appendRawValue(v);
        } else if (this.state === "nulls") {
          this.appendInt32(0);
          this.appendUint53(this.count);
        }
        this.state = "empty";
      }
      /**
       * Private method, do not call from outside the class.
       */
      appendRawValue(value) {
        if (this.type === "int") {
          this.appendInt53(value);
        } else if (this.type === "uint") {
          this.appendUint53(value);
        } else if (this.type === "utf8") {
          this.appendPrefixedString(value);
        } else {
          throw new RangeError(`Unknown RLEEncoder datatype: ${this.type}`);
        }
      }
      /**
       * Flushes any unwritten data to the buffer. Call this before reading from
       * the buffer constructed by this Encoder.
       */
      finish() {
        if (this.state === "literal") this.literal.push(this.lastValue);
        if (this.state !== "nulls" || this.offset > 0) this.flush();
      }
    };
    var RLEDecoder = class extends Decoder {
      constructor(type, buffer) {
        super(buffer);
        this.type = type;
        this.lastValue = void 0;
        this.count = 0;
        this.state = void 0;
      }
      /**
       * Returns false if there is still data to be read at the current decoding
       * position, and true if we are at the end of the buffer.
       */
      get done() {
        return this.count === 0 && this.offset === this.buf.byteLength;
      }
      /**
       * Resets the cursor position, so that the next read goes back to the
       * beginning of the buffer.
       */
      reset() {
        this.offset = 0;
        this.lastValue = void 0;
        this.count = 0;
        this.state = void 0;
      }
      /**
       * Returns the next value (or null) in the sequence.
       */
      readValue() {
        if (this.done) return null;
        if (this.count === 0) this.readRecord();
        this.count -= 1;
        if (this.state === "literal") {
          const value = this.readRawValue();
          if (value === this.lastValue) throw new RangeError("Repetition of values is not allowed in literal");
          this.lastValue = value;
          return value;
        } else {
          return this.lastValue;
        }
      }
      /**
       * Discards the next `numSkip` values in the sequence.
       */
      skipValues(numSkip) {
        while (numSkip > 0 && !this.done) {
          if (this.count === 0) {
            this.count = this.readInt53();
            if (this.count > 0) {
              this.lastValue = this.count <= numSkip ? this.skipRawValues(1) : this.readRawValue();
              this.state = "repetition";
            } else if (this.count < 0) {
              this.count = -this.count;
              this.state = "literal";
            } else {
              this.count = this.readUint53();
              this.lastValue = null;
              this.state = "nulls";
            }
          }
          const consume = Math.min(numSkip, this.count);
          if (this.state === "literal") this.skipRawValues(consume);
          numSkip -= consume;
          this.count -= consume;
        }
      }
      /**
       * Private method, do not call from outside the class.
       * Reads a repetition count from the buffer and sets up the state appropriately.
       */
      readRecord() {
        this.count = this.readInt53();
        if (this.count > 1) {
          const value = this.readRawValue();
          if ((this.state === "repetition" || this.state === "literal") && this.lastValue === value) {
            throw new RangeError("Successive repetitions with the same value are not allowed");
          }
          this.state = "repetition";
          this.lastValue = value;
        } else if (this.count === 1) {
          throw new RangeError("Repetition count of 1 is not allowed, use a literal instead");
        } else if (this.count < 0) {
          this.count = -this.count;
          if (this.state === "literal") throw new RangeError("Successive literals are not allowed");
          this.state = "literal";
        } else {
          if (this.state === "nulls") throw new RangeError("Successive null runs are not allowed");
          this.count = this.readUint53();
          if (this.count === 0) throw new RangeError("Zero-length null runs are not allowed");
          this.lastValue = null;
          this.state = "nulls";
        }
      }
      /**
       * Private method, do not call from outside the class.
       * Reads one value of the datatype configured on construction.
       */
      readRawValue() {
        if (this.type === "int") {
          return this.readInt53();
        } else if (this.type === "uint") {
          return this.readUint53();
        } else if (this.type === "utf8") {
          return this.readPrefixedString();
        } else {
          throw new RangeError(`Unknown RLEDecoder datatype: ${this.type}`);
        }
      }
      /**
       * Private method, do not call from outside the class.
       * Skips over `num` values of the datatype configured on construction.
       */
      skipRawValues(num) {
        if (this.type === "utf8") {
          for (let i = 0; i < num; i++) this.skip(this.readUint53());
        } else {
          while (num > 0 && this.offset < this.buf.byteLength) {
            if ((this.buf[this.offset] & 128) === 0) num--;
            this.offset++;
          }
          if (num > 0) throw new RangeError("cannot skip beyond end of buffer");
        }
      }
    };
    var DeltaEncoder = class extends RLEEncoder {
      constructor() {
        super("int");
        this.absoluteValue = 0;
      }
      /**
       * Appends a new integer value to the sequence. If `repetitions` is given, the value is repeated
       * `repetitions` times.
       */
      appendValue(value, repetitions = 1) {
        if (repetitions <= 0) return;
        if (typeof value === "number") {
          super.appendValue(value - this.absoluteValue, 1);
          this.absoluteValue = value;
          if (repetitions > 1) super.appendValue(0, repetitions - 1);
        } else {
          super.appendValue(value, repetitions);
        }
      }
      /**
       * Copies values from the DeltaDecoder `decoder` into this encoder. The `options` object may
       * contain the key `count`, indicating the number of values to copy. If not specified, copies
       * all remaining values in the decoder.
       */
      copyFrom(decoder, options = {}) {
        if (options.sumValues) {
          throw new RangeError("unsupported options for DeltaEncoder.copyFrom()");
        }
        if (!(decoder instanceof DeltaDecoder)) {
          throw new TypeError("incompatible type of decoder");
        }
        let remaining = options.count;
        if (remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${remaining} values`);
        if (remaining === 0 || decoder.done) return;
        let value = decoder.readValue(), nulls = 0;
        this.appendValue(value);
        if (value === null) {
          nulls = decoder.count + 1;
          if (remaining !== void 0 && remaining < nulls) nulls = remaining;
          decoder.count -= nulls - 1;
          this.count += nulls - 1;
          if (remaining > nulls && decoder.done) throw new RangeError(`cannot copy ${remaining} values`);
          if (remaining === nulls || decoder.done) return;
          if (decoder.count === 0) this.appendValue(decoder.readValue());
        }
        if (remaining !== void 0) remaining -= nulls + 1;
        const { nonNullValues, sum } = super.copyFrom(decoder, { count: remaining, sumValues: true });
        if (nonNullValues > 0) {
          this.absoluteValue = sum;
          decoder.absoluteValue = sum;
        }
      }
    };
    var DeltaDecoder = class extends RLEDecoder {
      constructor(buffer) {
        super("int", buffer);
        this.absoluteValue = 0;
      }
      /**
       * Resets the cursor position, so that the next read goes back to the
       * beginning of the buffer.
       */
      reset() {
        this.offset = 0;
        this.lastValue = void 0;
        this.count = 0;
        this.state = void 0;
        this.absoluteValue = 0;
      }
      /**
       * Returns the next integer (or null) value in the sequence.
       */
      readValue() {
        const value = super.readValue();
        if (value === null) return null;
        this.absoluteValue += value;
        return this.absoluteValue;
      }
      /**
       * Discards the next `numSkip` values in the sequence.
       */
      skipValues(numSkip) {
        while (numSkip > 0 && !this.done) {
          if (this.count === 0) this.readRecord();
          const consume = Math.min(numSkip, this.count);
          if (this.state === "literal") {
            for (let i = 0; i < consume; i++) {
              this.lastValue = this.readRawValue();
              this.absoluteValue += this.lastValue;
            }
          } else if (this.state === "repetition") {
            this.absoluteValue += consume * this.lastValue;
          }
          numSkip -= consume;
          this.count -= consume;
        }
      }
    };
    var BooleanEncoder = class extends Encoder {
      constructor() {
        super();
        this.lastValue = false;
        this.count = 0;
      }
      /**
       * Appends a new value to the sequence. If `repetitions` is given, the value is repeated
       * `repetitions` times.
       */
      appendValue(value, repetitions = 1) {
        if (value !== false && value !== true) {
          throw new RangeError(`Unsupported value for BooleanEncoder: ${value}`);
        }
        if (repetitions <= 0) return;
        if (this.lastValue === value) {
          this.count += repetitions;
        } else {
          this.appendUint53(this.count);
          this.lastValue = value;
          this.count = repetitions;
        }
      }
      /**
       * Copies values from the BooleanDecoder `decoder` into this encoder. The `options` object may
       * contain the key `count`, indicating the number of values to copy. If not specified, copies
       * all remaining values in the decoder.
       */
      copyFrom(decoder, options = {}) {
        if (!(decoder instanceof BooleanDecoder)) {
          throw new TypeError("incompatible type of decoder");
        }
        const { count } = options;
        let remaining = typeof count === "number" ? count : Number.MAX_SAFE_INTEGER;
        if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);
        if (remaining === 0 || decoder.done) return;
        this.appendValue(decoder.readValue());
        remaining--;
        const firstCopy = Math.min(decoder.count, remaining);
        this.count += firstCopy;
        decoder.count -= firstCopy;
        remaining -= firstCopy;
        while (remaining > 0 && !decoder.done) {
          decoder.count = decoder.readUint53();
          if (decoder.count === 0) throw new RangeError("Zero-length runs are not allowed");
          decoder.lastValue = !decoder.lastValue;
          this.appendUint53(this.count);
          const numCopied = Math.min(decoder.count, remaining);
          this.count = numCopied;
          this.lastValue = decoder.lastValue;
          decoder.count -= numCopied;
          remaining -= numCopied;
        }
        if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`);
      }
      /**
       * Flushes any unwritten data to the buffer. Call this before reading from
       * the buffer constructed by this Encoder.
       */
      finish() {
        if (this.count > 0) {
          this.appendUint53(this.count);
          this.count = 0;
        }
      }
    };
    var BooleanDecoder = class extends Decoder {
      constructor(buffer) {
        super(buffer);
        this.lastValue = true;
        this.firstRun = true;
        this.count = 0;
      }
      /**
       * Returns false if there is still data to be read at the current decoding
       * position, and true if we are at the end of the buffer.
       */
      get done() {
        return this.count === 0 && this.offset === this.buf.byteLength;
      }
      /**
       * Resets the cursor position, so that the next read goes back to the
       * beginning of the buffer.
       */
      reset() {
        this.offset = 0;
        this.lastValue = true;
        this.firstRun = true;
        this.count = 0;
      }
      /**
       * Returns the next value in the sequence.
       */
      readValue() {
        if (this.done) return false;
        while (this.count === 0) {
          this.count = this.readUint53();
          this.lastValue = !this.lastValue;
          if (this.count === 0 && !this.firstRun) {
            throw new RangeError("Zero-length runs are not allowed");
          }
          this.firstRun = false;
        }
        this.count -= 1;
        return this.lastValue;
      }
      /**
       * Discards the next `numSkip` values in the sequence.
       */
      skipValues(numSkip) {
        while (numSkip > 0 && !this.done) {
          if (this.count === 0) {
            this.count = this.readUint53();
            this.lastValue = !this.lastValue;
            if (this.count === 0 && !this.firstRun) {
              throw new RangeError("Zero-length runs are not allowed");
            }
            this.firstRun = false;
          }
          if (this.count < numSkip) {
            numSkip -= this.count;
            this.count = 0;
          } else {
            this.count -= numSkip;
            numSkip = 0;
          }
        }
      }
    };
    module.exports = {
      stringToUtf8,
      utf8ToString,
      hexStringToBytes,
      bytesToHexString,
      Encoder,
      Decoder,
      RLEEncoder,
      RLEDecoder,
      DeltaEncoder,
      DeltaDecoder,
      BooleanEncoder,
      BooleanDecoder
    };
  }
});

// node_modules/fast-sha256/sha256.js
var require_sha256 = __commonJS({
  "node_modules/fast-sha256/sha256.js"(exports, module) {
    (function(root, factory) {
      var exports2 = {};
      factory(exports2);
      var sha256 = exports2["default"];
      for (var k in exports2) {
        sha256[k] = exports2[k];
      }
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = sha256;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return sha256;
        });
      } else {
        root.sha256 = sha256;
      }
    })(exports, function(exports2) {
      "use strict";
      exports2.__esModule = true;
      exports2.digestLength = 32;
      exports2.blockSize = 64;
      var K = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      function hashBlocks(w, v, p, pos, len) {
        var a, b, c, d, e, f, g, h, u, i, j, t1, t2;
        while (len >= 64) {
          a = v[0];
          b = v[1];
          c = v[2];
          d = v[3];
          e = v[4];
          f = v[5];
          g = v[6];
          h = v[7];
          for (i = 0; i < 16; i++) {
            j = pos + i * 4;
            w[i] = (p[j] & 255) << 24 | (p[j + 1] & 255) << 16 | (p[j + 2] & 255) << 8 | p[j + 3] & 255;
          }
          for (i = 16; i < 64; i++) {
            u = w[i - 2];
            t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
            u = w[i - 15];
            t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
          }
          for (i = 0; i < 64; i++) {
            t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
            t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
            h = g;
            g = f;
            f = e;
            e = d + t1 | 0;
            d = c;
            c = b;
            b = a;
            a = t1 + t2 | 0;
          }
          v[0] += a;
          v[1] += b;
          v[2] += c;
          v[3] += d;
          v[4] += e;
          v[5] += f;
          v[6] += g;
          v[7] += h;
          pos += 64;
          len -= 64;
        }
        return pos;
      }
      var Hash = (
        /** @class */
        function() {
          function Hash2() {
            this.digestLength = exports2.digestLength;
            this.blockSize = exports2.blockSize;
            this.state = new Int32Array(8);
            this.temp = new Int32Array(64);
            this.buffer = new Uint8Array(128);
            this.bufferLength = 0;
            this.bytesHashed = 0;
            this.finished = false;
            this.reset();
          }
          Hash2.prototype.reset = function() {
            this.state[0] = 1779033703;
            this.state[1] = 3144134277;
            this.state[2] = 1013904242;
            this.state[3] = 2773480762;
            this.state[4] = 1359893119;
            this.state[5] = 2600822924;
            this.state[6] = 528734635;
            this.state[7] = 1541459225;
            this.bufferLength = 0;
            this.bytesHashed = 0;
            this.finished = false;
            return this;
          };
          Hash2.prototype.clean = function() {
            for (var i = 0; i < this.buffer.length; i++) {
              this.buffer[i] = 0;
            }
            for (var i = 0; i < this.temp.length; i++) {
              this.temp[i] = 0;
            }
            this.reset();
          };
          Hash2.prototype.update = function(data, dataLength) {
            if (dataLength === void 0) {
              dataLength = data.length;
            }
            if (this.finished) {
              throw new Error("SHA256: can't update because hash was finished.");
            }
            var dataPos = 0;
            this.bytesHashed += dataLength;
            if (this.bufferLength > 0) {
              while (this.bufferLength < 64 && dataLength > 0) {
                this.buffer[this.bufferLength++] = data[dataPos++];
                dataLength--;
              }
              if (this.bufferLength === 64) {
                hashBlocks(this.temp, this.state, this.buffer, 0, 64);
                this.bufferLength = 0;
              }
            }
            if (dataLength >= 64) {
              dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
              dataLength %= 64;
            }
            while (dataLength > 0) {
              this.buffer[this.bufferLength++] = data[dataPos++];
              dataLength--;
            }
            return this;
          };
          Hash2.prototype.finish = function(out) {
            if (!this.finished) {
              var bytesHashed = this.bytesHashed;
              var left = this.bufferLength;
              var bitLenHi = bytesHashed / 536870912 | 0;
              var bitLenLo = bytesHashed << 3;
              var padLength = bytesHashed % 64 < 56 ? 64 : 128;
              this.buffer[left] = 128;
              for (var i = left + 1; i < padLength - 8; i++) {
                this.buffer[i] = 0;
              }
              this.buffer[padLength - 8] = bitLenHi >>> 24 & 255;
              this.buffer[padLength - 7] = bitLenHi >>> 16 & 255;
              this.buffer[padLength - 6] = bitLenHi >>> 8 & 255;
              this.buffer[padLength - 5] = bitLenHi >>> 0 & 255;
              this.buffer[padLength - 4] = bitLenLo >>> 24 & 255;
              this.buffer[padLength - 3] = bitLenLo >>> 16 & 255;
              this.buffer[padLength - 2] = bitLenLo >>> 8 & 255;
              this.buffer[padLength - 1] = bitLenLo >>> 0 & 255;
              hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
              this.finished = true;
            }
            for (var i = 0; i < 8; i++) {
              out[i * 4 + 0] = this.state[i] >>> 24 & 255;
              out[i * 4 + 1] = this.state[i] >>> 16 & 255;
              out[i * 4 + 2] = this.state[i] >>> 8 & 255;
              out[i * 4 + 3] = this.state[i] >>> 0 & 255;
            }
            return this;
          };
          Hash2.prototype.digest = function() {
            var out = new Uint8Array(this.digestLength);
            this.finish(out);
            return out;
          };
          Hash2.prototype._saveState = function(out) {
            for (var i = 0; i < this.state.length; i++) {
              out[i] = this.state[i];
            }
          };
          Hash2.prototype._restoreState = function(from, bytesHashed) {
            for (var i = 0; i < this.state.length; i++) {
              this.state[i] = from[i];
            }
            this.bytesHashed = bytesHashed;
            this.finished = false;
            this.bufferLength = 0;
          };
          return Hash2;
        }()
      );
      exports2.Hash = Hash;
      var HMAC = (
        /** @class */
        function() {
          function HMAC2(key) {
            this.inner = new Hash();
            this.outer = new Hash();
            this.blockSize = this.inner.blockSize;
            this.digestLength = this.inner.digestLength;
            var pad = new Uint8Array(this.blockSize);
            if (key.length > this.blockSize) {
              new Hash().update(key).finish(pad).clean();
            } else {
              for (var i = 0; i < key.length; i++) {
                pad[i] = key[i];
              }
            }
            for (var i = 0; i < pad.length; i++) {
              pad[i] ^= 54;
            }
            this.inner.update(pad);
            for (var i = 0; i < pad.length; i++) {
              pad[i] ^= 54 ^ 92;
            }
            this.outer.update(pad);
            this.istate = new Uint32Array(8);
            this.ostate = new Uint32Array(8);
            this.inner._saveState(this.istate);
            this.outer._saveState(this.ostate);
            for (var i = 0; i < pad.length; i++) {
              pad[i] = 0;
            }
          }
          HMAC2.prototype.reset = function() {
            this.inner._restoreState(this.istate, this.inner.blockSize);
            this.outer._restoreState(this.ostate, this.outer.blockSize);
            return this;
          };
          HMAC2.prototype.clean = function() {
            for (var i = 0; i < this.istate.length; i++) {
              this.ostate[i] = this.istate[i] = 0;
            }
            this.inner.clean();
            this.outer.clean();
          };
          HMAC2.prototype.update = function(data) {
            this.inner.update(data);
            return this;
          };
          HMAC2.prototype.finish = function(out) {
            if (this.outer.finished) {
              this.outer.finish(out);
            } else {
              this.inner.finish(out);
              this.outer.update(out, this.digestLength).finish(out);
            }
            return this;
          };
          HMAC2.prototype.digest = function() {
            var out = new Uint8Array(this.digestLength);
            this.finish(out);
            return out;
          };
          return HMAC2;
        }()
      );
      exports2.HMAC = HMAC;
      function hash(data) {
        var h = new Hash().update(data);
        var digest = h.digest();
        h.clean();
        return digest;
      }
      exports2.hash = hash;
      exports2["default"] = hash;
      function hmac(key, data) {
        var h = new HMAC(key).update(data);
        var digest = h.digest();
        h.clean();
        return digest;
      }
      exports2.hmac = hmac;
      function fillBuffer(buffer, hmac2, info, counter) {
        var num = counter[0];
        if (num === 0) {
          throw new Error("hkdf: cannot expand more");
        }
        hmac2.reset();
        if (num > 1) {
          hmac2.update(buffer);
        }
        if (info) {
          hmac2.update(info);
        }
        hmac2.update(counter);
        hmac2.finish(buffer);
        counter[0]++;
      }
      var hkdfSalt = new Uint8Array(exports2.digestLength);
      function hkdf(key, salt, info, length) {
        if (salt === void 0) {
          salt = hkdfSalt;
        }
        if (length === void 0) {
          length = 32;
        }
        var counter = new Uint8Array([1]);
        var okm = hmac(salt, key);
        var hmac_ = new HMAC(okm);
        var buffer = new Uint8Array(hmac_.digestLength);
        var bufpos = buffer.length;
        var out = new Uint8Array(length);
        for (var i = 0; i < length; i++) {
          if (bufpos === buffer.length) {
            fillBuffer(buffer, hmac_, info, counter);
            bufpos = 0;
          }
          out[i] = buffer[bufpos++];
        }
        hmac_.clean();
        buffer.fill(0);
        counter.fill(0);
        return out;
      }
      exports2.hkdf = hkdf;
      function pbkdf2(password, salt, iterations, dkLen) {
        var prf = new HMAC(password);
        var len = prf.digestLength;
        var ctr = new Uint8Array(4);
        var t = new Uint8Array(len);
        var u = new Uint8Array(len);
        var dk = new Uint8Array(dkLen);
        for (var i = 0; i * len < dkLen; i++) {
          var c = i + 1;
          ctr[0] = c >>> 24 & 255;
          ctr[1] = c >>> 16 & 255;
          ctr[2] = c >>> 8 & 255;
          ctr[3] = c >>> 0 & 255;
          prf.reset();
          prf.update(salt);
          prf.update(ctr);
          prf.finish(u);
          for (var j = 0; j < len; j++) {
            t[j] = u[j];
          }
          for (var j = 2; j <= iterations; j++) {
            prf.reset();
            prf.update(u).finish(u);
            for (var k = 0; k < len; k++) {
              t[k] ^= u[k];
            }
          }
          for (var j = 0; j < len && i * len + j < dkLen; j++) {
            dk[i * len + j] = t[j];
          }
        }
        for (var i = 0; i < len; i++) {
          t[i] = u[i] = 0;
        }
        for (var i = 0; i < 4; i++) {
          ctr[i] = 0;
        }
        prf.clean();
        return dk;
      }
      exports2.pbkdf2 = pbkdf2;
    });
  }
});

// node_modules/automerge/backend/columnar.js
var require_columnar = __commonJS({
  "node_modules/automerge/backend/columnar.js"(exports, module) {
    var pako = require_pako();
    var { copyObject, parseOpId, equalBytes } = require_common();
    var {
      utf8ToString,
      hexStringToBytes,
      bytesToHexString,
      Encoder,
      Decoder,
      RLEEncoder,
      RLEDecoder,
      DeltaEncoder,
      DeltaDecoder,
      BooleanEncoder,
      BooleanDecoder
    } = require_encoding();
    var { Hash } = require_sha256();
    var MAGIC_BYTES = new Uint8Array([133, 111, 74, 131]);
    var CHUNK_TYPE_DOCUMENT = 0;
    var CHUNK_TYPE_CHANGE = 1;
    var CHUNK_TYPE_DEFLATE = 2;
    var DEFLATE_MIN_SIZE = 256;
    var COLUMN_TYPE = {
      GROUP_CARD: 0,
      ACTOR_ID: 1,
      INT_RLE: 2,
      INT_DELTA: 3,
      BOOLEAN: 4,
      STRING_RLE: 5,
      VALUE_LEN: 6,
      VALUE_RAW: 7
    };
    var COLUMN_TYPE_DEFLATE = 8;
    var VALUE_TYPE = {
      NULL: 0,
      FALSE: 1,
      TRUE: 2,
      LEB128_UINT: 3,
      LEB128_INT: 4,
      IEEE754: 5,
      UTF8: 6,
      BYTES: 7,
      COUNTER: 8,
      TIMESTAMP: 9,
      MIN_UNKNOWN: 10,
      MAX_UNKNOWN: 15
    };
    var ACTIONS = ["makeMap", "set", "makeList", "del", "makeText", "inc", "makeTable", "link"];
    var OBJECT_TYPE = { makeMap: "map", makeList: "list", makeText: "text", makeTable: "table" };
    var COMMON_COLUMNS = [
      { columnName: "objActor", columnId: 0 << 4 | COLUMN_TYPE.ACTOR_ID },
      { columnName: "objCtr", columnId: 0 << 4 | COLUMN_TYPE.INT_RLE },
      { columnName: "keyActor", columnId: 1 << 4 | COLUMN_TYPE.ACTOR_ID },
      { columnName: "keyCtr", columnId: 1 << 4 | COLUMN_TYPE.INT_DELTA },
      { columnName: "keyStr", columnId: 1 << 4 | COLUMN_TYPE.STRING_RLE },
      { columnName: "idActor", columnId: 2 << 4 | COLUMN_TYPE.ACTOR_ID },
      { columnName: "idCtr", columnId: 2 << 4 | COLUMN_TYPE.INT_DELTA },
      { columnName: "insert", columnId: 3 << 4 | COLUMN_TYPE.BOOLEAN },
      { columnName: "action", columnId: 4 << 4 | COLUMN_TYPE.INT_RLE },
      { columnName: "valLen", columnId: 5 << 4 | COLUMN_TYPE.VALUE_LEN },
      { columnName: "valRaw", columnId: 5 << 4 | COLUMN_TYPE.VALUE_RAW },
      { columnName: "chldActor", columnId: 6 << 4 | COLUMN_TYPE.ACTOR_ID },
      { columnName: "chldCtr", columnId: 6 << 4 | COLUMN_TYPE.INT_DELTA }
    ];
    var CHANGE_COLUMNS = COMMON_COLUMNS.concat([
      { columnName: "predNum", columnId: 7 << 4 | COLUMN_TYPE.GROUP_CARD },
      { columnName: "predActor", columnId: 7 << 4 | COLUMN_TYPE.ACTOR_ID },
      { columnName: "predCtr", columnId: 7 << 4 | COLUMN_TYPE.INT_DELTA }
    ]);
    var DOC_OPS_COLUMNS = COMMON_COLUMNS.concat([
      { columnName: "succNum", columnId: 8 << 4 | COLUMN_TYPE.GROUP_CARD },
      { columnName: "succActor", columnId: 8 << 4 | COLUMN_TYPE.ACTOR_ID },
      { columnName: "succCtr", columnId: 8 << 4 | COLUMN_TYPE.INT_DELTA }
    ]);
    var DOCUMENT_COLUMNS = [
      { columnName: "actor", columnId: 0 << 4 | COLUMN_TYPE.ACTOR_ID },
      { columnName: "seq", columnId: 0 << 4 | COLUMN_TYPE.INT_DELTA },
      { columnName: "maxOp", columnId: 1 << 4 | COLUMN_TYPE.INT_DELTA },
      { columnName: "time", columnId: 2 << 4 | COLUMN_TYPE.INT_DELTA },
      { columnName: "message", columnId: 3 << 4 | COLUMN_TYPE.STRING_RLE },
      { columnName: "depsNum", columnId: 4 << 4 | COLUMN_TYPE.GROUP_CARD },
      { columnName: "depsIndex", columnId: 4 << 4 | COLUMN_TYPE.INT_DELTA },
      { columnName: "extraLen", columnId: 5 << 4 | COLUMN_TYPE.VALUE_LEN },
      { columnName: "extraRaw", columnId: 5 << 4 | COLUMN_TYPE.VALUE_RAW }
    ];
    function actorIdToActorNum(opId, actorIds) {
      if (!opId || !opId.actorId) return opId;
      const counter = opId.counter;
      const actorNum = actorIds.indexOf(opId.actorId);
      if (actorNum < 0) throw new RangeError("missing actorId");
      return { counter, actorNum, actorId: opId.actorId };
    }
    function compareParsedOpIds(id1, id2) {
      if (id1.counter < id2.counter) return -1;
      if (id1.counter > id2.counter) return 1;
      if (id1.actorId < id2.actorId) return -1;
      if (id1.actorId > id2.actorId) return 1;
      return 0;
    }
    function parseAllOpIds(changes, single) {
      const actors = {}, newChanges = [];
      for (let change of changes) {
        change = copyObject(change);
        actors[change.actor] = true;
        change.ops = expandMultiOps(change.ops, change.startOp, change.actor);
        change.ops = change.ops.map((op) => {
          op = copyObject(op);
          if (op.obj !== "_root") op.obj = parseOpId(op.obj);
          if (op.elemId && op.elemId !== "_head") op.elemId = parseOpId(op.elemId);
          if (op.child) op.child = parseOpId(op.child);
          if (op.pred) op.pred = op.pred.map(parseOpId);
          if (op.obj.actorId) actors[op.obj.actorId] = true;
          if (op.elemId && op.elemId.actorId) actors[op.elemId.actorId] = true;
          if (op.child && op.child.actorId) actors[op.child.actorId] = true;
          for (let pred of op.pred) actors[pred.actorId] = true;
          return op;
        });
        newChanges.push(change);
      }
      let actorIds = Object.keys(actors).sort();
      if (single) {
        actorIds = [changes[0].actor].concat(actorIds.filter((actor) => actor !== changes[0].actor));
      }
      for (let change of newChanges) {
        change.actorNum = actorIds.indexOf(change.actor);
        for (let i = 0; i < change.ops.length; i++) {
          let op = change.ops[i];
          op.id = { counter: change.startOp + i, actorNum: change.actorNum, actorId: change.actor };
          op.obj = actorIdToActorNum(op.obj, actorIds);
          op.elemId = actorIdToActorNum(op.elemId, actorIds);
          op.child = actorIdToActorNum(op.child, actorIds);
          op.pred = op.pred.map((pred) => actorIdToActorNum(pred, actorIds));
        }
      }
      return { changes: newChanges, actorIds };
    }
    function encodeObjectId(op, columns) {
      if (op.obj === "_root") {
        columns.objActor.appendValue(null);
        columns.objCtr.appendValue(null);
      } else if (op.obj.actorNum >= 0 && op.obj.counter > 0) {
        columns.objActor.appendValue(op.obj.actorNum);
        columns.objCtr.appendValue(op.obj.counter);
      } else {
        throw new RangeError(`Unexpected objectId reference: ${JSON.stringify(op.obj)}`);
      }
    }
    function encodeOperationKey(op, columns) {
      if (op.key) {
        columns.keyActor.appendValue(null);
        columns.keyCtr.appendValue(null);
        columns.keyStr.appendValue(op.key);
      } else if (op.elemId === "_head" && op.insert) {
        columns.keyActor.appendValue(null);
        columns.keyCtr.appendValue(0);
        columns.keyStr.appendValue(null);
      } else if (op.elemId && op.elemId.actorNum >= 0 && op.elemId.counter > 0) {
        columns.keyActor.appendValue(op.elemId.actorNum);
        columns.keyCtr.appendValue(op.elemId.counter);
        columns.keyStr.appendValue(null);
      } else {
        throw new RangeError(`Unexpected operation key: ${JSON.stringify(op)}`);
      }
    }
    function encodeOperationAction(op, columns) {
      const actionCode = ACTIONS.indexOf(op.action);
      if (actionCode >= 0) {
        columns.action.appendValue(actionCode);
      } else if (typeof op.action === "number") {
        columns.action.appendValue(op.action);
      } else {
        throw new RangeError(`Unexpected operation action: ${op.action}`);
      }
    }
    function getNumberTypeAndValue(op) {
      switch (op.datatype) {
        case "counter":
          return [VALUE_TYPE.COUNTER, op.value];
        case "timestamp":
          return [VALUE_TYPE.TIMESTAMP, op.value];
        case "uint":
          return [VALUE_TYPE.LEB128_UINT, op.value];
        case "int":
          return [VALUE_TYPE.LEB128_INT, op.value];
        case "float64": {
          const buf64 = new ArrayBuffer(8), view64 = new DataView(buf64);
          view64.setFloat64(0, op.value, true);
          return [VALUE_TYPE.IEEE754, new Uint8Array(buf64)];
        }
        default:
          if (Number.isInteger(op.value) && op.value <= Number.MAX_SAFE_INTEGER && op.value >= Number.MIN_SAFE_INTEGER) {
            return [VALUE_TYPE.LEB128_INT, op.value];
          } else {
            const buf64 = new ArrayBuffer(8), view64 = new DataView(buf64);
            view64.setFloat64(0, op.value, true);
            return [VALUE_TYPE.IEEE754, new Uint8Array(buf64)];
          }
      }
    }
    function encodeValue(op, columns) {
      if (op.action !== "set" && op.action !== "inc" || op.value === null) {
        columns.valLen.appendValue(VALUE_TYPE.NULL);
      } else if (op.value === false) {
        columns.valLen.appendValue(VALUE_TYPE.FALSE);
      } else if (op.value === true) {
        columns.valLen.appendValue(VALUE_TYPE.TRUE);
      } else if (typeof op.value === "string") {
        const numBytes = columns.valRaw.appendRawString(op.value);
        columns.valLen.appendValue(numBytes << 4 | VALUE_TYPE.UTF8);
      } else if (ArrayBuffer.isView(op.value)) {
        const numBytes = columns.valRaw.appendRawBytes(new Uint8Array(op.value.buffer));
        columns.valLen.appendValue(numBytes << 4 | VALUE_TYPE.BYTES);
      } else if (typeof op.value === "number") {
        let [typeTag, value] = getNumberTypeAndValue(op);
        let numBytes;
        if (typeTag === VALUE_TYPE.LEB128_UINT) {
          numBytes = columns.valRaw.appendUint53(value);
        } else if (typeTag === VALUE_TYPE.IEEE754) {
          numBytes = columns.valRaw.appendRawBytes(value);
        } else {
          numBytes = columns.valRaw.appendInt53(value);
        }
        columns.valLen.appendValue(numBytes << 4 | typeTag);
      } else if (typeof op.datatype === "number" && op.datatype >= VALUE_TYPE.MIN_UNKNOWN && op.datatype <= VALUE_TYPE.MAX_UNKNOWN && op.value instanceof Uint8Array) {
        const numBytes = columns.valRaw.appendRawBytes(op.value);
        columns.valLen.appendValue(numBytes << 4 | op.datatype);
      } else if (op.datatype) {
        throw new RangeError(`Unknown datatype ${op.datatype} for value ${op.value}`);
      } else {
        throw new RangeError(`Unsupported value in operation: ${op.value}`);
      }
    }
    function decodeValue(sizeTag, bytes) {
      if (sizeTag === VALUE_TYPE.NULL) {
        return { value: null };
      } else if (sizeTag === VALUE_TYPE.FALSE) {
        return { value: false };
      } else if (sizeTag === VALUE_TYPE.TRUE) {
        return { value: true };
      } else if (sizeTag % 16 === VALUE_TYPE.UTF8) {
        return { value: utf8ToString(bytes) };
      } else {
        if (sizeTag % 16 === VALUE_TYPE.LEB128_UINT) {
          return { value: new Decoder(bytes).readUint53(), datatype: "uint" };
        } else if (sizeTag % 16 === VALUE_TYPE.LEB128_INT) {
          return { value: new Decoder(bytes).readInt53(), datatype: "int" };
        } else if (sizeTag % 16 === VALUE_TYPE.IEEE754) {
          const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
          if (bytes.byteLength === 8) {
            return { value: view.getFloat64(0, true), datatype: "float64" };
          } else {
            throw new RangeError(`Invalid length for floating point number: ${bytes.byteLength}`);
          }
        } else if (sizeTag % 16 === VALUE_TYPE.COUNTER) {
          return { value: new Decoder(bytes).readInt53(), datatype: "counter" };
        } else if (sizeTag % 16 === VALUE_TYPE.TIMESTAMP) {
          return { value: new Decoder(bytes).readInt53(), datatype: "timestamp" };
        } else {
          return { value: bytes, datatype: sizeTag % 16 };
        }
      }
    }
    function decodeValueColumns(columns, colIndex, actorIds, result) {
      const { columnId, columnName, decoder } = columns[colIndex];
      if (columnId % 8 === COLUMN_TYPE.VALUE_LEN && colIndex + 1 < columns.length && columns[colIndex + 1].columnId === columnId + 1) {
        const sizeTag = decoder.readValue();
        const rawValue = columns[colIndex + 1].decoder.readRawBytes(sizeTag >> 4);
        const { value, datatype } = decodeValue(sizeTag, rawValue);
        result[columnName] = value;
        if (datatype) result[columnName + "_datatype"] = datatype;
        return 2;
      } else if (columnId % 8 === COLUMN_TYPE.ACTOR_ID) {
        const actorNum = decoder.readValue();
        if (actorNum === null) {
          result[columnName] = null;
        } else {
          if (!actorIds[actorNum]) throw new RangeError(`No actor index ${actorNum}`);
          result[columnName] = actorIds[actorNum];
        }
      } else {
        result[columnName] = decoder.readValue();
      }
      return 1;
    }
    function encodeOps(ops, forDocument) {
      const columns = {
        objActor: new RLEEncoder("uint"),
        objCtr: new RLEEncoder("uint"),
        keyActor: new RLEEncoder("uint"),
        keyCtr: new DeltaEncoder(),
        keyStr: new RLEEncoder("utf8"),
        insert: new BooleanEncoder(),
        action: new RLEEncoder("uint"),
        valLen: new RLEEncoder("uint"),
        valRaw: new Encoder(),
        chldActor: new RLEEncoder("uint"),
        chldCtr: new DeltaEncoder()
      };
      if (forDocument) {
        columns.idActor = new RLEEncoder("uint");
        columns.idCtr = new DeltaEncoder();
        columns.succNum = new RLEEncoder("uint");
        columns.succActor = new RLEEncoder("uint");
        columns.succCtr = new DeltaEncoder();
      } else {
        columns.predNum = new RLEEncoder("uint");
        columns.predCtr = new DeltaEncoder();
        columns.predActor = new RLEEncoder("uint");
      }
      for (let op of ops) {
        encodeObjectId(op, columns);
        encodeOperationKey(op, columns);
        columns.insert.appendValue(!!op.insert);
        encodeOperationAction(op, columns);
        encodeValue(op, columns);
        if (op.child && op.child.counter) {
          columns.chldActor.appendValue(op.child.actorNum);
          columns.chldCtr.appendValue(op.child.counter);
        } else {
          columns.chldActor.appendValue(null);
          columns.chldCtr.appendValue(null);
        }
        if (forDocument) {
          columns.idActor.appendValue(op.id.actorNum);
          columns.idCtr.appendValue(op.id.counter);
          columns.succNum.appendValue(op.succ.length);
          op.succ.sort(compareParsedOpIds);
          for (let i = 0; i < op.succ.length; i++) {
            columns.succActor.appendValue(op.succ[i].actorNum);
            columns.succCtr.appendValue(op.succ[i].counter);
          }
        } else {
          columns.predNum.appendValue(op.pred.length);
          op.pred.sort(compareParsedOpIds);
          for (let i = 0; i < op.pred.length; i++) {
            columns.predActor.appendValue(op.pred[i].actorNum);
            columns.predCtr.appendValue(op.pred[i].counter);
          }
        }
      }
      let columnList = [];
      for (let { columnName, columnId } of forDocument ? DOC_OPS_COLUMNS : CHANGE_COLUMNS) {
        if (columns[columnName]) columnList.push({ columnId, columnName, encoder: columns[columnName] });
      }
      return columnList.sort((a, b) => a.columnId - b.columnId);
    }
    function validDatatype(value, datatype) {
      if (datatype === void 0) {
        return typeof value === "string" || typeof value === "boolean" || value === null;
      } else {
        return typeof value === "number";
      }
    }
    function expandMultiOps(ops, startOp, actor) {
      let opNum = startOp;
      let expandedOps = [];
      for (const op of ops) {
        if (op.action === "set" && op.values && op.insert) {
          if (op.pred.length !== 0) throw new RangeError("multi-insert pred must be empty");
          let lastElemId = op.elemId;
          const datatype = op.datatype;
          for (const value of op.values) {
            if (!validDatatype(value, datatype)) throw new RangeError(`Decode failed: bad value/datatype association (${value},${datatype})`);
            expandedOps.push({ action: "set", obj: op.obj, elemId: lastElemId, datatype, value, pred: [], insert: true });
            lastElemId = `${opNum}@${actor}`;
            opNum += 1;
          }
        } else if (op.action === "del" && op.multiOp > 1) {
          if (op.pred.length !== 1) throw new RangeError("multiOp deletion must have exactly one pred");
          const startElemId = parseOpId(op.elemId), startPred = parseOpId(op.pred[0]);
          for (let i = 0; i < op.multiOp; i++) {
            const elemId = `${startElemId.counter + i}@${startElemId.actorId}`;
            const pred = [`${startPred.counter + i}@${startPred.actorId}`];
            expandedOps.push({ action: "del", obj: op.obj, elemId, pred });
            opNum += 1;
          }
        } else {
          expandedOps.push(op);
          opNum += 1;
        }
      }
      return expandedOps;
    }
    function decodeOps(ops, forDocument) {
      const newOps = [];
      for (let op of ops) {
        const obj = op.objCtr === null ? "_root" : `${op.objCtr}@${op.objActor}`;
        const elemId = op.keyStr ? void 0 : op.keyCtr === 0 ? "_head" : `${op.keyCtr}@${op.keyActor}`;
        const action = ACTIONS[op.action] || op.action;
        const newOp = elemId ? { obj, elemId, action } : { obj, key: op.keyStr, action };
        newOp.insert = !!op.insert;
        if (ACTIONS[op.action] === "set" || ACTIONS[op.action] === "inc") {
          newOp.value = op.valLen;
          if (op.valLen_datatype) newOp.datatype = op.valLen_datatype;
        }
        if (!!op.chldCtr !== !!op.chldActor) {
          throw new RangeError(`Mismatched child columns: ${op.chldCtr} and ${op.chldActor}`);
        }
        if (op.chldCtr !== null) newOp.child = `${op.chldCtr}@${op.chldActor}`;
        if (forDocument) {
          newOp.id = `${op.idCtr}@${op.idActor}`;
          newOp.succ = op.succNum.map((succ) => `${succ.succCtr}@${succ.succActor}`);
          checkSortedOpIds(op.succNum.map((succ) => ({ counter: succ.succCtr, actorId: succ.succActor })));
        } else {
          newOp.pred = op.predNum.map((pred) => `${pred.predCtr}@${pred.predActor}`);
          checkSortedOpIds(op.predNum.map((pred) => ({ counter: pred.predCtr, actorId: pred.predActor })));
        }
        newOps.push(newOp);
      }
      return newOps;
    }
    function checkSortedOpIds(opIds) {
      let last = null;
      for (let opId of opIds) {
        if (last && compareParsedOpIds(last, opId) !== -1) {
          throw new RangeError("operation IDs are not in ascending order");
        }
        last = opId;
      }
    }
    function encoderByColumnId(columnId) {
      if ((columnId & 7) === COLUMN_TYPE.INT_DELTA) {
        return new DeltaEncoder();
      } else if ((columnId & 7) === COLUMN_TYPE.BOOLEAN) {
        return new BooleanEncoder();
      } else if ((columnId & 7) === COLUMN_TYPE.STRING_RLE) {
        return new RLEEncoder("utf8");
      } else if ((columnId & 7) === COLUMN_TYPE.VALUE_RAW) {
        return new Encoder();
      } else {
        return new RLEEncoder("uint");
      }
    }
    function decoderByColumnId(columnId, buffer) {
      if ((columnId & 7) === COLUMN_TYPE.INT_DELTA) {
        return new DeltaDecoder(buffer);
      } else if ((columnId & 7) === COLUMN_TYPE.BOOLEAN) {
        return new BooleanDecoder(buffer);
      } else if ((columnId & 7) === COLUMN_TYPE.STRING_RLE) {
        return new RLEDecoder("utf8", buffer);
      } else if ((columnId & 7) === COLUMN_TYPE.VALUE_RAW) {
        return new Decoder(buffer);
      } else {
        return new RLEDecoder("uint", buffer);
      }
    }
    function makeDecoders(columns, columnSpec) {
      const emptyBuf = new Uint8Array(0);
      let decoders = [], columnIndex = 0, specIndex = 0;
      while (columnIndex < columns.length || specIndex < columnSpec.length) {
        if (columnIndex === columns.length || specIndex < columnSpec.length && columnSpec[specIndex].columnId < columns[columnIndex].columnId) {
          const { columnId, columnName } = columnSpec[specIndex];
          decoders.push({ columnId, columnName, decoder: decoderByColumnId(columnId, emptyBuf) });
          specIndex++;
        } else if (specIndex === columnSpec.length || columns[columnIndex].columnId < columnSpec[specIndex].columnId) {
          const { columnId, buffer } = columns[columnIndex];
          decoders.push({ columnId, decoder: decoderByColumnId(columnId, buffer) });
          columnIndex++;
        } else {
          const { columnId, buffer } = columns[columnIndex], { columnName } = columnSpec[specIndex];
          decoders.push({ columnId, columnName, decoder: decoderByColumnId(columnId, buffer) });
          columnIndex++;
          specIndex++;
        }
      }
      return decoders;
    }
    function decodeColumns(columns, actorIds, columnSpec) {
      columns = makeDecoders(columns, columnSpec);
      let parsedRows = [];
      while (columns.some((col) => !col.decoder.done)) {
        let row = {}, col = 0;
        while (col < columns.length) {
          const columnId = columns[col].columnId;
          let groupId = columnId >> 4, groupCols = 1;
          while (col + groupCols < columns.length && columns[col + groupCols].columnId >> 4 === groupId) {
            groupCols++;
          }
          if (columnId % 8 === COLUMN_TYPE.GROUP_CARD) {
            const values = [], count = columns[col].decoder.readValue();
            for (let i = 0; i < count; i++) {
              let value = {};
              for (let colOffset = 1; colOffset < groupCols; colOffset++) {
                decodeValueColumns(columns, col + colOffset, actorIds, value);
              }
              values.push(value);
            }
            row[columns[col].columnName] = values;
            col += groupCols;
          } else {
            col += decodeValueColumns(columns, col, actorIds, row);
          }
        }
        parsedRows.push(row);
      }
      return parsedRows;
    }
    function decodeColumnInfo(decoder) {
      const COLUMN_ID_MASK = (-1 ^ COLUMN_TYPE_DEFLATE) >>> 0;
      let lastColumnId = -1, columns = [], numColumns = decoder.readUint53();
      for (let i = 0; i < numColumns; i++) {
        const columnId = decoder.readUint53(), bufferLen = decoder.readUint53();
        if ((columnId & COLUMN_ID_MASK) <= (lastColumnId & COLUMN_ID_MASK)) {
          throw new RangeError("Columns must be in ascending order");
        }
        lastColumnId = columnId;
        columns.push({ columnId, bufferLen });
      }
      return columns;
    }
    function encodeColumnInfo(encoder, columns) {
      const nonEmptyColumns = columns.filter((column) => column.encoder.buffer.byteLength > 0);
      encoder.appendUint53(nonEmptyColumns.length);
      for (let column of nonEmptyColumns) {
        encoder.appendUint53(column.columnId);
        encoder.appendUint53(column.encoder.buffer.byteLength);
      }
    }
    function decodeChangeHeader(decoder) {
      const numDeps = decoder.readUint53(), deps = [];
      for (let i = 0; i < numDeps; i++) {
        deps.push(bytesToHexString(decoder.readRawBytes(32)));
      }
      let change = {
        actor: decoder.readHexString(),
        seq: decoder.readUint53(),
        startOp: decoder.readUint53(),
        time: decoder.readInt53(),
        message: decoder.readPrefixedString(),
        deps
      };
      const actorIds = [change.actor], numActorIds = decoder.readUint53();
      for (let i = 0; i < numActorIds; i++) actorIds.push(decoder.readHexString());
      change.actorIds = actorIds;
      return change;
    }
    function encodeContainer(chunkType, encodeContentsCallback) {
      const CHECKSUM_SIZE = 4;
      const HEADER_SPACE = MAGIC_BYTES.byteLength + CHECKSUM_SIZE + 1 + 5;
      const body = new Encoder();
      body.appendRawBytes(new Uint8Array(HEADER_SPACE));
      encodeContentsCallback(body);
      const bodyBuf = body.buffer;
      const header = new Encoder();
      header.appendByte(chunkType);
      header.appendUint53(bodyBuf.byteLength - HEADER_SPACE);
      const headerBuf = header.buffer;
      const sha256 = new Hash();
      sha256.update(headerBuf);
      sha256.update(bodyBuf.subarray(HEADER_SPACE));
      const hash = sha256.digest(), checksum = hash.subarray(0, CHECKSUM_SIZE);
      bodyBuf.set(MAGIC_BYTES, HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE - MAGIC_BYTES.byteLength);
      bodyBuf.set(checksum, HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE);
      bodyBuf.set(headerBuf, HEADER_SPACE - headerBuf.byteLength);
      return { hash, bytes: bodyBuf.subarray(HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE - MAGIC_BYTES.byteLength) };
    }
    function decodeContainerHeader(decoder, computeHash) {
      if (!equalBytes(decoder.readRawBytes(MAGIC_BYTES.byteLength), MAGIC_BYTES)) {
        throw new RangeError("Data does not begin with magic bytes 85 6f 4a 83");
      }
      const expectedHash = decoder.readRawBytes(4);
      const hashStartOffset = decoder.offset;
      const chunkType = decoder.readByte();
      const chunkLength = decoder.readUint53();
      const header = { chunkType, chunkLength, chunkData: decoder.readRawBytes(chunkLength) };
      if (computeHash) {
        const sha256 = new Hash();
        sha256.update(decoder.buf.subarray(hashStartOffset, decoder.offset));
        const binaryHash = sha256.digest();
        if (!equalBytes(binaryHash.subarray(0, 4), expectedHash)) {
          throw new RangeError("checksum does not match data");
        }
        header.hash = bytesToHexString(binaryHash);
      }
      return header;
    }
    function encodeChange(changeObj) {
      const { changes, actorIds } = parseAllOpIds([changeObj], true);
      const change = changes[0];
      const { hash, bytes } = encodeContainer(CHUNK_TYPE_CHANGE, (encoder) => {
        if (!Array.isArray(change.deps)) throw new TypeError("deps is not an array");
        encoder.appendUint53(change.deps.length);
        for (let hash2 of change.deps.slice().sort()) {
          encoder.appendRawBytes(hexStringToBytes(hash2));
        }
        encoder.appendHexString(change.actor);
        encoder.appendUint53(change.seq);
        encoder.appendUint53(change.startOp);
        encoder.appendInt53(change.time);
        encoder.appendPrefixedString(change.message || "");
        encoder.appendUint53(actorIds.length - 1);
        for (let actor of actorIds.slice(1)) encoder.appendHexString(actor);
        const columns = encodeOps(change.ops, false);
        encodeColumnInfo(encoder, columns);
        for (let column of columns) encoder.appendRawBytes(column.encoder.buffer);
        if (change.extraBytes) encoder.appendRawBytes(change.extraBytes);
      });
      const hexHash = bytesToHexString(hash);
      if (changeObj.hash && changeObj.hash !== hexHash) {
        throw new RangeError(`Change hash does not match encoding: ${changeObj.hash} != ${hexHash}`);
      }
      return bytes.byteLength >= DEFLATE_MIN_SIZE ? deflateChange(bytes) : bytes;
    }
    function decodeChangeColumns(buffer) {
      if (buffer[8] === CHUNK_TYPE_DEFLATE) buffer = inflateChange(buffer);
      const decoder = new Decoder(buffer);
      const header = decodeContainerHeader(decoder, true);
      const chunkDecoder = new Decoder(header.chunkData);
      if (!decoder.done) throw new RangeError("Encoded change has trailing data");
      if (header.chunkType !== CHUNK_TYPE_CHANGE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`);
      const change = decodeChangeHeader(chunkDecoder);
      const columns = decodeColumnInfo(chunkDecoder);
      for (let i = 0; i < columns.length; i++) {
        if ((columns[i].columnId & COLUMN_TYPE_DEFLATE) !== 0) {
          throw new RangeError("change must not contain deflated columns");
        }
        columns[i].buffer = chunkDecoder.readRawBytes(columns[i].bufferLen);
      }
      if (!chunkDecoder.done) {
        const restLen = chunkDecoder.buf.byteLength - chunkDecoder.offset;
        change.extraBytes = chunkDecoder.readRawBytes(restLen);
      }
      change.columns = columns;
      change.hash = header.hash;
      return change;
    }
    function decodeChange(buffer) {
      const change = decodeChangeColumns(buffer);
      change.ops = decodeOps(decodeColumns(change.columns, change.actorIds, CHANGE_COLUMNS), false);
      delete change.actorIds;
      delete change.columns;
      return change;
    }
    function decodeChangeMeta(buffer, computeHash) {
      if (buffer[8] === CHUNK_TYPE_DEFLATE) buffer = inflateChange(buffer);
      const header = decodeContainerHeader(new Decoder(buffer), computeHash);
      if (header.chunkType !== CHUNK_TYPE_CHANGE) {
        throw new RangeError("Buffer chunk type is not a change");
      }
      const meta = decodeChangeHeader(new Decoder(header.chunkData));
      meta.change = buffer;
      if (computeHash) meta.hash = header.hash;
      return meta;
    }
    function deflateChange(buffer) {
      const header = decodeContainerHeader(new Decoder(buffer), false);
      if (header.chunkType !== CHUNK_TYPE_CHANGE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`);
      const compressed = pako.deflateRaw(header.chunkData);
      const encoder = new Encoder();
      encoder.appendRawBytes(buffer.subarray(0, 8));
      encoder.appendByte(CHUNK_TYPE_DEFLATE);
      encoder.appendUint53(compressed.byteLength);
      encoder.appendRawBytes(compressed);
      return encoder.buffer;
    }
    function inflateChange(buffer) {
      const header = decodeContainerHeader(new Decoder(buffer), false);
      if (header.chunkType !== CHUNK_TYPE_DEFLATE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`);
      const decompressed = pako.inflateRaw(header.chunkData);
      const encoder = new Encoder();
      encoder.appendRawBytes(buffer.subarray(0, 8));
      encoder.appendByte(CHUNK_TYPE_CHANGE);
      encoder.appendUint53(decompressed.byteLength);
      encoder.appendRawBytes(decompressed);
      return encoder.buffer;
    }
    function splitContainers(buffer) {
      let decoder = new Decoder(buffer), chunks = [], startOffset = 0;
      while (!decoder.done) {
        decodeContainerHeader(decoder, false);
        chunks.push(buffer.subarray(startOffset, decoder.offset));
        startOffset = decoder.offset;
      }
      return chunks;
    }
    function decodeChanges(binaryChanges) {
      let decoded = [];
      for (let binaryChange of binaryChanges) {
        for (let chunk of splitContainers(binaryChange)) {
          if (chunk[8] === CHUNK_TYPE_DOCUMENT) {
            decoded = decoded.concat(decodeDocument(chunk));
          } else if (chunk[8] === CHUNK_TYPE_CHANGE || chunk[8] === CHUNK_TYPE_DEFLATE) {
            decoded.push(decodeChange(chunk));
          } else {
          }
        }
      }
      return decoded;
    }
    function sortOpIds(a, b) {
      if (a === b) return 0;
      if (a === "_root") return -1;
      if (b === "_root") return 1;
      const a_ = parseOpId(a), b_ = parseOpId(b);
      if (a_.counter < b_.counter) return -1;
      if (a_.counter > b_.counter) return 1;
      if (a_.actorId < b_.actorId) return -1;
      if (a_.actorId > b_.actorId) return 1;
      return 0;
    }
    function groupChangeOps(changes, ops) {
      let changesByActor = {};
      for (let change of changes) {
        change.ops = [];
        if (!changesByActor[change.actor]) changesByActor[change.actor] = [];
        if (change.seq !== changesByActor[change.actor].length + 1) {
          throw new RangeError(`Expected seq = ${changesByActor[change.actor].length + 1}, got ${change.seq}`);
        }
        if (change.seq > 1 && changesByActor[change.actor][change.seq - 2].maxOp > change.maxOp) {
          throw new RangeError("maxOp must increase monotonically per actor");
        }
        changesByActor[change.actor].push(change);
      }
      let opsById = {};
      for (let op of ops) {
        if (op.action === "del") throw new RangeError("document should not contain del operations");
        op.pred = opsById[op.id] ? opsById[op.id].pred : [];
        opsById[op.id] = op;
        for (let succ of op.succ) {
          if (!opsById[succ]) {
            if (op.elemId) {
              const elemId = op.insert ? op.id : op.elemId;
              opsById[succ] = { id: succ, action: "del", obj: op.obj, elemId, pred: [] };
            } else {
              opsById[succ] = { id: succ, action: "del", obj: op.obj, key: op.key, pred: [] };
            }
          }
          opsById[succ].pred.push(op.id);
        }
        delete op.succ;
      }
      for (let op of Object.values(opsById)) {
        if (op.action === "del") ops.push(op);
      }
      for (let op of ops) {
        const { counter, actorId } = parseOpId(op.id);
        const actorChanges = changesByActor[actorId];
        let left = 0, right = actorChanges.length;
        while (left < right) {
          const index = Math.floor((left + right) / 2);
          if (actorChanges[index].maxOp < counter) {
            left = index + 1;
          } else {
            right = index;
          }
        }
        if (left >= actorChanges.length) {
          throw new RangeError(`Operation ID ${op.id} outside of allowed range`);
        }
        actorChanges[left].ops.push(op);
      }
      for (let change of changes) {
        change.ops.sort((op1, op2) => sortOpIds(op1.id, op2.id));
        change.startOp = change.maxOp - change.ops.length + 1;
        delete change.maxOp;
        for (let i = 0; i < change.ops.length; i++) {
          const op = change.ops[i], expectedId = `${change.startOp + i}@${change.actor}`;
          if (op.id !== expectedId) {
            throw new RangeError(`Expected opId ${expectedId}, got ${op.id}`);
          }
          delete op.id;
        }
      }
    }
    function decodeDocumentChanges(changes, expectedHeads) {
      let heads = {};
      for (let i2 = 0; i2 < changes.length; i2++) {
        let change = changes[i2];
        change.deps = [];
        for (let index of change.depsNum.map((d) => d.depsIndex)) {
          if (!changes[index] || !changes[index].hash) {
            throw new RangeError(`No hash for index ${index} while processing index ${i2}`);
          }
          const hash = changes[index].hash;
          change.deps.push(hash);
          if (heads[hash]) delete heads[hash];
        }
        change.deps.sort();
        delete change.depsNum;
        if (change.extraLen_datatype !== VALUE_TYPE.BYTES) {
          throw new RangeError(`Bad datatype for extra bytes: ${VALUE_TYPE.BYTES}`);
        }
        change.extraBytes = change.extraLen;
        delete change.extraLen_datatype;
        changes[i2] = decodeChange(encodeChange(change));
        heads[changes[i2].hash] = true;
      }
      const actualHeads = Object.keys(heads).sort();
      let headsEqual = actualHeads.length === expectedHeads.length, i = 0;
      while (headsEqual && i < actualHeads.length) {
        headsEqual = actualHeads[i] === expectedHeads[i];
        i++;
      }
      if (!headsEqual) {
        throw new RangeError(`Mismatched heads hashes: expected ${expectedHeads.join(", ")}, got ${actualHeads.join(", ")}`);
      }
    }
    function encodeDocumentHeader(doc) {
      const { changesColumns, opsColumns, actorIds, heads, headsIndexes, extraBytes } = doc;
      for (let column of changesColumns) deflateColumn(column);
      for (let column of opsColumns) deflateColumn(column);
      return encodeContainer(CHUNK_TYPE_DOCUMENT, (encoder) => {
        encoder.appendUint53(actorIds.length);
        for (let actor of actorIds) {
          encoder.appendHexString(actor);
        }
        encoder.appendUint53(heads.length);
        for (let head of heads.sort()) {
          encoder.appendRawBytes(hexStringToBytes(head));
        }
        encodeColumnInfo(encoder, changesColumns);
        encodeColumnInfo(encoder, opsColumns);
        for (let column of changesColumns) encoder.appendRawBytes(column.encoder.buffer);
        for (let column of opsColumns) encoder.appendRawBytes(column.encoder.buffer);
        for (let index of headsIndexes) encoder.appendUint53(index);
        if (extraBytes) encoder.appendRawBytes(extraBytes);
      }).bytes;
    }
    function decodeDocumentHeader(buffer) {
      const documentDecoder = new Decoder(buffer);
      const header = decodeContainerHeader(documentDecoder, true);
      const decoder = new Decoder(header.chunkData);
      if (!documentDecoder.done) throw new RangeError("Encoded document has trailing data");
      if (header.chunkType !== CHUNK_TYPE_DOCUMENT) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`);
      const actorIds = [], numActors = decoder.readUint53();
      for (let i = 0; i < numActors; i++) {
        actorIds.push(decoder.readHexString());
      }
      const heads = [], headsIndexes = [], numHeads = decoder.readUint53();
      for (let i = 0; i < numHeads; i++) {
        heads.push(bytesToHexString(decoder.readRawBytes(32)));
      }
      const changesColumns = decodeColumnInfo(decoder);
      const opsColumns = decodeColumnInfo(decoder);
      for (let i = 0; i < changesColumns.length; i++) {
        changesColumns[i].buffer = decoder.readRawBytes(changesColumns[i].bufferLen);
        inflateColumn(changesColumns[i]);
      }
      for (let i = 0; i < opsColumns.length; i++) {
        opsColumns[i].buffer = decoder.readRawBytes(opsColumns[i].bufferLen);
        inflateColumn(opsColumns[i]);
      }
      if (!decoder.done) {
        for (let i = 0; i < numHeads; i++) headsIndexes.push(decoder.readUint53());
      }
      const extraBytes = decoder.readRawBytes(decoder.buf.byteLength - decoder.offset);
      return { changesColumns, opsColumns, actorIds, heads, headsIndexes, extraBytes };
    }
    function decodeDocument(buffer) {
      const { changesColumns, opsColumns, actorIds, heads } = decodeDocumentHeader(buffer);
      const changes = decodeColumns(changesColumns, actorIds, DOCUMENT_COLUMNS);
      const ops = decodeOps(decodeColumns(opsColumns, actorIds, DOC_OPS_COLUMNS), true);
      groupChangeOps(changes, ops);
      decodeDocumentChanges(changes, heads);
      return changes;
    }
    function deflateColumn(column) {
      if (column.encoder.buffer.byteLength >= DEFLATE_MIN_SIZE) {
        column.encoder = { buffer: pako.deflateRaw(column.encoder.buffer) };
        column.columnId |= COLUMN_TYPE_DEFLATE;
      }
    }
    function inflateColumn(column) {
      if ((column.columnId & COLUMN_TYPE_DEFLATE) !== 0) {
        column.buffer = pako.inflateRaw(column.buffer);
        column.columnId ^= COLUMN_TYPE_DEFLATE;
      }
    }
    module.exports = {
      COLUMN_TYPE,
      VALUE_TYPE,
      ACTIONS,
      OBJECT_TYPE,
      DOC_OPS_COLUMNS,
      CHANGE_COLUMNS,
      DOCUMENT_COLUMNS,
      encoderByColumnId,
      decoderByColumnId,
      makeDecoders,
      decodeValue,
      splitContainers,
      encodeChange,
      decodeChangeColumns,
      decodeChange,
      decodeChangeMeta,
      decodeChanges,
      encodeDocumentHeader,
      decodeDocumentHeader,
      decodeDocument
    };
  }
});

// node_modules/automerge/backend/new.js
var require_new = __commonJS({
  "node_modules/automerge/backend/new.js"(exports, module) {
    var { parseOpId, copyObject } = require_common();
    var {
      COLUMN_TYPE,
      VALUE_TYPE,
      ACTIONS,
      OBJECT_TYPE,
      DOC_OPS_COLUMNS,
      CHANGE_COLUMNS,
      DOCUMENT_COLUMNS,
      encoderByColumnId,
      decoderByColumnId,
      makeDecoders,
      decodeValue,
      encodeChange,
      decodeChangeColumns,
      decodeChangeMeta,
      decodeChanges,
      decodeDocumentHeader,
      encodeDocumentHeader
    } = require_columnar();
    var MAX_BLOCK_SIZE = 600;
    var BLOOM_BITS_PER_ENTRY = 10;
    var BLOOM_NUM_PROBES = 7;
    var BLOOM_FILTER_SIZE = Math.floor(BLOOM_BITS_PER_ENTRY * MAX_BLOCK_SIZE / 8);
    var objActorIdx = 0;
    var objCtrIdx = 1;
    var keyActorIdx = 2;
    var keyCtrIdx = 3;
    var keyStrIdx = 4;
    var idActorIdx = 5;
    var idCtrIdx = 6;
    var insertIdx = 7;
    var actionIdx = 8;
    var valLenIdx = 9;
    var valRawIdx = 10;
    var predNumIdx = 13;
    var predActorIdx = 14;
    var predCtrIdx = 15;
    var succNumIdx = 13;
    var succActorIdx = 14;
    var succCtrIdx = 15;
    var PRED_COLUMN_IDS = CHANGE_COLUMNS.filter((column) => ["predNum", "predActor", "predCtr"].includes(column.columnName)).map((column) => column.columnId);
    function deepCopyUpdate(objectTree, path, value) {
      if (path.length === 1) {
        objectTree[path[0]] = value;
      } else {
        let child = Object.assign({}, objectTree[path[0]]);
        deepCopyUpdate(child, path.slice(1), value);
        objectTree[path[0]] = child;
      }
    }
    function seekWithinBlock(ops, docCols, actorIds, resumeInsertion) {
      for (let col of docCols) col.decoder.reset();
      const { objActor, objCtr, keyActor, keyCtr, keyStr, idActor, idCtr, insert } = ops;
      const [
        objActorD,
        objCtrD,
        /* keyActorD */
        ,
        /* keyCtrD */
        ,
        keyStrD,
        idActorD,
        idCtrD,
        insertD,
        actionD,
        /* valLenD */
        ,
        /* valRawD */
        ,
        /* chldActorD */
        ,
        /* chldCtrD */
        ,
        succNumD
      ] = docCols.map((col) => col.decoder);
      let skipCount = 0, visibleCount = 0, elemVisible = false, nextObjActor = null, nextObjCtr = null;
      let nextIdActor = null, nextIdCtr = null, nextKeyStr = null, nextInsert = null, nextSuccNum = 0;
      if (objCtr !== null && !resumeInsertion) {
        while (!objCtrD.done || !objActorD.done || !actionD.done) {
          nextObjCtr = objCtrD.readValue();
          nextObjActor = actorIds[objActorD.readValue()];
          actionD.skipValues(1);
          if (nextObjCtr === null || !nextObjActor || nextObjCtr < objCtr || nextObjCtr === objCtr && nextObjActor < objActor) {
            skipCount += 1;
          } else {
            break;
          }
        }
      }
      if ((nextObjCtr !== objCtr || nextObjActor !== objActor) && !resumeInsertion) {
        return { found: true, skipCount, visibleCount };
      }
      if (keyStr !== null) {
        keyStrD.skipValues(skipCount);
        while (!keyStrD.done) {
          const objActorIndex = objActorD.readValue();
          nextObjActor = objActorIndex === null ? null : actorIds[objActorIndex];
          nextObjCtr = objCtrD.readValue();
          nextKeyStr = keyStrD.readValue();
          if (nextKeyStr !== null && nextKeyStr < keyStr && nextObjCtr === objCtr && nextObjActor === objActor) {
            skipCount += 1;
          } else {
            break;
          }
        }
        return { found: true, skipCount, visibleCount };
      }
      idCtrD.skipValues(skipCount);
      idActorD.skipValues(skipCount);
      insertD.skipValues(skipCount);
      succNumD.skipValues(skipCount);
      nextIdCtr = idCtrD.readValue();
      nextIdActor = actorIds[idActorD.readValue()];
      nextInsert = insertD.readValue();
      nextSuccNum = succNumD.readValue();
      if (insert) {
        if (!resumeInsertion && keyCtr !== null && keyCtr > 0 && keyActor !== null) {
          skipCount += 1;
          while (!idCtrD.done && !idActorD.done && (nextIdCtr !== keyCtr || nextIdActor !== keyActor)) {
            if (nextInsert) elemVisible = false;
            if (nextSuccNum === 0 && !elemVisible) {
              visibleCount += 1;
              elemVisible = true;
            }
            nextIdCtr = idCtrD.readValue();
            nextIdActor = actorIds[idActorD.readValue()];
            nextObjCtr = objCtrD.readValue();
            nextObjActor = actorIds[objActorD.readValue()];
            nextInsert = insertD.readValue();
            nextSuccNum = succNumD.readValue();
            if (nextObjCtr === objCtr && nextObjActor === objActor) skipCount += 1;
            else break;
          }
          if (nextObjCtr !== objCtr || nextObjActor !== objActor || nextIdCtr !== keyCtr || nextIdActor !== keyActor || !nextInsert) {
            return { found: false, skipCount, visibleCount };
          }
          if (nextInsert) elemVisible = false;
          if (nextSuccNum === 0 && !elemVisible) {
            visibleCount += 1;
            elemVisible = true;
          }
          if (idCtrD.done || idActorD.done) return { found: true, skipCount, visibleCount };
          nextIdCtr = idCtrD.readValue();
          nextIdActor = actorIds[idActorD.readValue()];
          nextObjCtr = objCtrD.readValue();
          nextObjActor = actorIds[objActorD.readValue()];
          nextInsert = insertD.readValue();
          nextSuccNum = succNumD.readValue();
        }
        while ((!nextInsert || nextIdCtr > idCtr || nextIdCtr === idCtr && nextIdActor > idActor) && nextObjCtr === objCtr && nextObjActor === objActor) {
          skipCount += 1;
          if (nextInsert) elemVisible = false;
          if (nextSuccNum === 0 && !elemVisible) {
            visibleCount += 1;
            elemVisible = true;
          }
          if (!idCtrD.done && !idActorD.done) {
            nextIdCtr = idCtrD.readValue();
            nextIdActor = actorIds[idActorD.readValue()];
            nextObjCtr = objCtrD.readValue();
            nextObjActor = actorIds[objActorD.readValue()];
            nextInsert = insertD.readValue();
            nextSuccNum = succNumD.readValue();
          } else {
            break;
          }
        }
      } else if (keyCtr !== null && keyCtr > 0 && keyActor !== null) {
        while ((!nextInsert || nextIdCtr !== keyCtr || nextIdActor !== keyActor) && nextObjCtr === objCtr && nextObjActor === objActor) {
          skipCount += 1;
          if (nextInsert) elemVisible = false;
          if (nextSuccNum === 0 && !elemVisible) {
            visibleCount += 1;
            elemVisible = true;
          }
          if (!idCtrD.done && !idActorD.done) {
            nextIdCtr = idCtrD.readValue();
            nextIdActor = actorIds[idActorD.readValue()];
            nextObjCtr = objCtrD.readValue();
            nextObjActor = actorIds[objActorD.readValue()];
            nextInsert = insertD.readValue();
            nextSuccNum = succNumD.readValue();
          } else {
            break;
          }
        }
        if (nextObjCtr !== objCtr || nextObjActor !== objActor || nextIdCtr !== keyCtr || nextIdActor !== keyActor || !nextInsert) {
          return { found: false, skipCount, visibleCount };
        }
      }
      return { found: true, skipCount, visibleCount };
    }
    function visibleListElements(docState, blockIndex, objActorNum, objCtr) {
      const thisBlock = docState.blocks[blockIndex];
      const nextBlock = docState.blocks[blockIndex + 1];
      if (thisBlock.lastObjectActor !== objActorNum || thisBlock.lastObjectCtr !== objCtr || thisBlock.numVisible === void 0) {
        return 0;
      } else if (thisBlock.lastVisibleActor === nextBlock.firstVisibleActor && thisBlock.lastVisibleActor !== void 0 && thisBlock.lastVisibleCtr === nextBlock.firstVisibleCtr && thisBlock.lastVisibleCtr !== void 0) {
        return thisBlock.numVisible - 1;
      } else {
        return thisBlock.numVisible;
      }
    }
    function seekToOp(docState, ops) {
      const { objActor, objActorNum, objCtr, keyActor, keyCtr, keyStr } = ops;
      let blockIndex = 0, totalVisible = 0;
      if (objCtr !== null) {
        while (blockIndex < docState.blocks.length - 1) {
          const blockActor = docState.blocks[blockIndex].lastObjectActor === void 0 ? void 0 : docState.actorIds[docState.blocks[blockIndex].lastObjectActor];
          const blockCtr = docState.blocks[blockIndex].lastObjectCtr;
          if (blockCtr === null || blockCtr < objCtr || blockCtr === objCtr && blockActor < objActor) {
            blockIndex++;
          } else {
            break;
          }
        }
      }
      if (keyStr !== null) {
        while (blockIndex < docState.blocks.length - 1) {
          const { lastObjectActor, lastObjectCtr, lastKey } = docState.blocks[blockIndex];
          if (objCtr === lastObjectCtr && objActorNum === lastObjectActor && lastKey !== void 0 && lastKey < keyStr) blockIndex++;
          else break;
        }
        const { skipCount } = seekWithinBlock(ops, docState.blocks[blockIndex].columns, docState.actorIds, false);
        return { blockIndex, skipCount, visibleCount: 0 };
      } else {
        const insertAtHead = keyCtr === null || keyCtr === 0 || keyActor === null;
        const keyActorNum = keyActor === null ? null : docState.actorIds.indexOf(keyActor);
        let resumeInsertion = false;
        while (true) {
          if (!insertAtHead && !resumeInsertion) {
            while (blockIndex < docState.blocks.length - 1 && docState.blocks[blockIndex].lastObjectActor === objActorNum && docState.blocks[blockIndex].lastObjectCtr === objCtr && !bloomFilterContains(docState.blocks[blockIndex].bloom, keyActorNum, keyCtr)) {
              if (docState.blocks[blockIndex].lastObjectCtr > objCtr) {
                throw new RangeError(`Reference element not found: ${keyCtr}@${keyActor}`);
              }
              totalVisible += visibleListElements(docState, blockIndex, objActorNum, objCtr);
              blockIndex++;
            }
          }
          const { found, skipCount, visibleCount } = seekWithinBlock(
            ops,
            docState.blocks[blockIndex].columns,
            docState.actorIds,
            resumeInsertion
          );
          if (blockIndex === docState.blocks.length - 1 || docState.blocks[blockIndex].lastObjectActor !== objActorNum || docState.blocks[blockIndex].lastObjectCtr !== objCtr) {
            if (found) {
              return { blockIndex, skipCount, visibleCount: totalVisible + visibleCount };
            } else {
              throw new RangeError(`Reference element not found: ${keyCtr}@${keyActor}`);
            }
          } else if (found && skipCount < docState.blocks[blockIndex].numOps) {
            return { blockIndex, skipCount, visibleCount: totalVisible + visibleCount };
          }
          resumeInsertion = found && ops.insert;
          totalVisible += visibleListElements(docState, blockIndex, objActorNum, objCtr);
          blockIndex++;
        }
      }
    }
    function bloomFilterAdd(bloom, elemIdActor, elemIdCtr) {
      let modulo = 8 * bloom.byteLength, x = elemIdCtr % modulo, y = elemIdActor % modulo;
      let z = ((elemIdCtr ^ elemIdActor) * 16777619 >>> 0) % modulo;
      for (let i = 0; i < BLOOM_NUM_PROBES; i++) {
        bloom[x >>> 3] |= 1 << (x & 7);
        x = (x + y) % modulo;
        y = (y + z) % modulo;
      }
    }
    function bloomFilterContains(bloom, elemIdActor, elemIdCtr) {
      let modulo = 8 * bloom.byteLength, x = elemIdCtr % modulo, y = elemIdActor % modulo;
      let z = ((elemIdCtr ^ elemIdActor) * 16777619 >>> 0) % modulo;
      for (let i = 0; i < BLOOM_NUM_PROBES; i++) {
        if ((bloom[x >>> 3] & 1 << (x & 7)) === 0) {
          return false;
        }
        x = (x + y) % modulo;
        y = (y + z) % modulo;
      }
      return true;
    }
    function updateBlockMetadata(block) {
      block.bloom = new Uint8Array(BLOOM_FILTER_SIZE);
      block.numOps = 0;
      block.lastKey = void 0;
      block.numVisible = void 0;
      block.lastObjectActor = void 0;
      block.lastObjectCtr = void 0;
      block.firstVisibleActor = void 0;
      block.firstVisibleCtr = void 0;
      block.lastVisibleActor = void 0;
      block.lastVisibleCtr = void 0;
      for (let col of block.columns) col.decoder.reset();
      const [
        objActorD,
        objCtrD,
        keyActorD,
        keyCtrD,
        keyStrD,
        idActorD,
        idCtrD,
        insertD,
        /* actionD */
        ,
        /* valLenD */
        ,
        /* valRawD */
        ,
        /* chldActorD */
        ,
        /* chldCtrD */
        ,
        succNumD
      ] = block.columns.map((col) => col.decoder);
      while (!idCtrD.done) {
        block.numOps += 1;
        const objActor = objActorD.readValue(), objCtr = objCtrD.readValue();
        const keyActor = keyActorD.readValue(), keyCtr = keyCtrD.readValue(), keyStr = keyStrD.readValue();
        const idActor = idActorD.readValue(), idCtr = idCtrD.readValue();
        const insert = insertD.readValue(), succNum = succNumD.readValue();
        if (block.lastObjectActor !== objActor || block.lastObjectCtr !== objCtr) {
          block.numVisible = 0;
          block.lastObjectActor = objActor;
          block.lastObjectCtr = objCtr;
        }
        if (keyStr !== null) {
          block.lastKey = keyStr;
        } else if (insert || keyCtr !== null) {
          block.lastKey = void 0;
          const elemIdActor = insert ? idActor : keyActor;
          const elemIdCtr = insert ? idCtr : keyCtr;
          bloomFilterAdd(block.bloom, elemIdActor, elemIdCtr);
          if (succNum === 0) {
            if (block.firstVisibleActor === void 0) block.firstVisibleActor = elemIdActor;
            if (block.firstVisibleCtr === void 0) block.firstVisibleCtr = elemIdCtr;
            if (block.lastVisibleActor !== elemIdActor || block.lastVisibleCtr !== elemIdCtr) {
              block.numVisible += 1;
              block.lastVisibleActor = elemIdActor;
              block.lastVisibleCtr = elemIdCtr;
            }
          }
        }
      }
    }
    function addBlockOperation(block, op, actorIds, isChangeOp) {
      if (op[keyStrIdx] !== null) {
        if (block.lastObjectCtr === op[objCtrIdx] && block.lastObjectActor === op[objActorIdx] && (block.lastKey === void 0 || block.lastKey < op[keyStrIdx])) {
          block.lastKey = op[keyStrIdx];
        }
      } else {
        const elemIdActor = op[insertIdx] ? op[idActorIdx] : op[keyActorIdx];
        const elemIdCtr = op[insertIdx] ? op[idCtrIdx] : op[keyCtrIdx];
        bloomFilterAdd(block.bloom, elemIdActor, elemIdCtr);
        if (op[succNumIdx] === 0 || isChangeOp) {
          if (block.firstVisibleActor === void 0) block.firstVisibleActor = elemIdActor;
          if (block.firstVisibleCtr === void 0) block.firstVisibleCtr = elemIdCtr;
          block.lastVisibleActor = elemIdActor;
          block.lastVisibleCtr = elemIdCtr;
        }
      }
      if (block.lastObjectCtr === void 0 || op[objActorIdx] !== null && op[objCtrIdx] !== null && (block.lastObjectCtr === null || block.lastObjectCtr < op[objCtrIdx] || block.lastObjectCtr === op[objCtrIdx] && actorIds[block.lastObjectActor] < actorIds[op[objActorIdx]])) {
        block.lastObjectActor = op[objActorIdx];
        block.lastObjectCtr = op[objCtrIdx];
        block.lastKey = op[keyStrIdx] !== null ? op[keyStrIdx] : void 0;
        block.numVisible = 0;
      }
    }
    function splitBlock(block) {
      for (let col of block.columns) col.decoder.reset();
      const numBlocks = Math.ceil(block.numOps / (0.8 * MAX_BLOCK_SIZE));
      let blocks = [], opsSoFar = 0;
      for (let i = 1; i <= numBlocks; i++) {
        const opsToCopy = Math.ceil(i * block.numOps / numBlocks) - opsSoFar;
        const encoders = block.columns.map((col) => ({ columnId: col.columnId, encoder: encoderByColumnId(col.columnId) }));
        copyColumns(encoders, block.columns, opsToCopy);
        const decoders = encoders.map((col) => {
          const decoder = decoderByColumnId(col.columnId, col.encoder.buffer);
          return { columnId: col.columnId, decoder };
        });
        const newBlock = { columns: decoders };
        updateBlockMetadata(newBlock);
        blocks.push(newBlock);
        opsSoFar += opsToCopy;
      }
      return blocks;
    }
    function concatBlocks(blocks) {
      const encoders = blocks[0].columns.map((col) => ({ columnId: col.columnId, encoder: encoderByColumnId(col.columnId) }));
      for (let block of blocks) {
        for (let col of block.columns) col.decoder.reset();
        copyColumns(encoders, block.columns, block.numOps);
      }
      return encoders;
    }
    function copyColumns(outCols, inCols, count) {
      if (count === 0) return;
      let inIndex = 0, lastGroup = -1, lastCardinality = 0, valueColumn = -1, valueBytes = 0;
      for (let outCol of outCols) {
        while (inIndex < inCols.length && inCols[inIndex].columnId < outCol.columnId) inIndex++;
        let inCol = null;
        if (inIndex < inCols.length && inCols[inIndex].columnId === outCol.columnId && inCols[inIndex].decoder.buf.byteLength > 0) {
          inCol = inCols[inIndex].decoder;
        }
        const colCount = outCol.columnId >> 4 === lastGroup ? lastCardinality : count;
        if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {
          lastGroup = outCol.columnId >> 4;
          if (inCol) {
            lastCardinality = outCol.encoder.copyFrom(inCol, { count, sumValues: true }).sum;
          } else {
            outCol.encoder.appendValue(0, count);
            lastCardinality = 0;
          }
        } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {
          if (inCol) {
            if (inIndex + 1 === inCols.length || inCols[inIndex + 1].columnId !== outCol.columnId + 1) {
              throw new RangeError("VALUE_LEN column without accompanying VALUE_RAW column");
            }
            valueColumn = outCol.columnId + 1;
            valueBytes = outCol.encoder.copyFrom(inCol, { count: colCount, sumValues: true, sumShift: 4 }).sum;
          } else {
            outCol.encoder.appendValue(null, colCount);
            valueColumn = outCol.columnId + 1;
            valueBytes = 0;
          }
        } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {
          if (outCol.columnId !== valueColumn) {
            throw new RangeError("VALUE_RAW column without accompanying VALUE_LEN column");
          }
          if (valueBytes > 0) {
            outCol.encoder.appendRawBytes(inCol.readRawBytes(valueBytes));
          }
        } else {
          if (inCol) {
            outCol.encoder.copyFrom(inCol, { count: colCount });
          } else {
            const blankValue = outCol.columnId % 8 === COLUMN_TYPE.BOOLEAN ? false : null;
            outCol.encoder.appendValue(blankValue, colCount);
          }
        }
      }
    }
    function readOperation(columns, actorTable) {
      let operation = [], colValue, lastGroup = -1, lastCardinality = 0, valueColumn = -1, valueBytes = 0;
      for (let col of columns) {
        if (col.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {
          if (col.columnId !== valueColumn) throw new RangeError("unexpected VALUE_RAW column");
          colValue = col.decoder.readRawBytes(valueBytes);
        } else if (col.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {
          lastGroup = col.columnId >> 4;
          lastCardinality = col.decoder.readValue() || 0;
          colValue = lastCardinality;
        } else if (col.columnId >> 4 === lastGroup) {
          colValue = [];
          if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {
            valueColumn = col.columnId + 1;
            valueBytes = 0;
          }
          for (let i = 0; i < lastCardinality; i++) {
            let value = col.decoder.readValue();
            if (col.columnId % 8 === COLUMN_TYPE.ACTOR_ID && actorTable && typeof value === "number") {
              value = actorTable[value];
            }
            if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {
              valueBytes += colValue >>> 4;
            }
            colValue.push(value);
          }
        } else {
          colValue = col.decoder.readValue();
          if (col.columnId % 8 === COLUMN_TYPE.ACTOR_ID && actorTable && typeof colValue === "number") {
            colValue = actorTable[colValue];
          }
          if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {
            valueColumn = col.columnId + 1;
            valueBytes = colValue >>> 4;
          }
        }
        operation.push(colValue);
      }
      return operation;
    }
    function appendOperation(outCols, inCols, operation) {
      let inIndex = 0, lastGroup = -1, lastCardinality = 0;
      for (let outCol of outCols) {
        while (inIndex < inCols.length && inCols[inIndex].columnId < outCol.columnId) inIndex++;
        if (inIndex < inCols.length && inCols[inIndex].columnId === outCol.columnId) {
          const colValue = operation[inIndex];
          if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {
            lastGroup = outCol.columnId >> 4;
            lastCardinality = colValue;
            outCol.encoder.appendValue(colValue);
          } else if (outCol.columnId >> 4 === lastGroup) {
            if (!Array.isArray(colValue) || colValue.length !== lastCardinality) {
              throw new RangeError("bad group value");
            }
            for (let v of colValue) outCol.encoder.appendValue(v);
          } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {
            if (colValue) outCol.encoder.appendRawBytes(colValue);
          } else {
            outCol.encoder.appendValue(colValue);
          }
        } else if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {
          lastGroup = outCol.columnId >> 4;
          lastCardinality = 0;
          outCol.encoder.appendValue(0);
        } else if (outCol.columnId % 8 !== COLUMN_TYPE.VALUE_RAW) {
          const count = outCol.columnId >> 4 === lastGroup ? lastCardinality : 1;
          let blankValue = null;
          if (outCol.columnId % 8 === COLUMN_TYPE.BOOLEAN) blankValue = false;
          if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_LEN) blankValue = 0;
          outCol.encoder.appendValue(blankValue, count);
        }
      }
    }
    function readNextDocOp(docState, blockIndex) {
      let block = docState.blocks[blockIndex];
      if (!block.columns[actionIdx].decoder.done) {
        return { docOp: readOperation(block.columns), blockIndex };
      } else if (blockIndex === docState.blocks.length - 1) {
        return { docOp: null, blockIndex };
      } else {
        blockIndex += 1;
        block = docState.blocks[blockIndex];
        for (let col of block.columns) col.decoder.reset();
        return { docOp: readOperation(block.columns), blockIndex };
      }
    }
    function readNextChangeOp(docState, changeState) {
      while (changeState.changeIndex < changeState.changes.length - 1 && (!changeState.columns || changeState.columns[actionIdx].decoder.done)) {
        changeState.changeIndex += 1;
        const change = changeState.changes[changeState.changeIndex];
        changeState.columns = makeDecoders(change.columns, CHANGE_COLUMNS);
        changeState.opCtr = change.startOp;
        if (changeState.columns[actionIdx].decoder.done) {
          change.maxOp = change.startOp - 1;
        }
        updateBlockColumns(docState, changeState.columns);
        const { actorIds, actorTable } = getActorTable(docState.actorIds, change);
        docState.actorIds = actorIds;
        changeState.actorTable = actorTable;
        changeState.actorIndex = docState.actorIds.indexOf(change.actorIds[0]);
      }
      if (changeState.columns[actionIdx].decoder.done) {
        changeState.done = true;
        changeState.nextOp = null;
        return;
      }
      changeState.nextOp = readOperation(changeState.columns, changeState.actorTable);
      changeState.nextOp[idActorIdx] = changeState.actorIndex;
      changeState.nextOp[idCtrIdx] = changeState.opCtr;
      changeState.changes[changeState.changeIndex].maxOp = changeState.opCtr;
      if (changeState.opCtr > docState.maxOp) docState.maxOp = changeState.opCtr;
      changeState.opCtr += 1;
      const op = changeState.nextOp;
      if (op[objCtrIdx] === null && op[objActorIdx] !== null || op[objCtrIdx] !== null && op[objActorIdx] === null) {
        throw new RangeError(`Mismatched object reference: (${op[objCtrIdx]}, ${op[objActorIdx]})`);
      }
      if (op[keyCtrIdx] === null && op[keyActorIdx] !== null || op[keyCtrIdx] === 0 && op[keyActorIdx] !== null || op[keyCtrIdx] > 0 && op[keyActorIdx] === null) {
        throw new RangeError(`Mismatched operation key: (${op[keyCtrIdx]}, ${op[keyActorIdx]})`);
      }
    }
    function emptyObjectPatch(objectId, type) {
      if (type === "list" || type === "text") {
        return { objectId, type, edits: [] };
      } else {
        return { objectId, type, props: {} };
      }
    }
    function opIdDelta(id1, id2, delta = 1) {
      const parsed1 = parseOpId(id1), parsed2 = parseOpId(id2);
      return parsed1.actorId === parsed2.actorId && parsed1.counter + delta === parsed2.counter;
    }
    function appendEdit(existingEdits, nextEdit) {
      if (existingEdits.length === 0) {
        existingEdits.push(nextEdit);
        return;
      }
      let lastEdit = existingEdits[existingEdits.length - 1];
      if (lastEdit.action === "insert" && nextEdit.action === "insert" && lastEdit.index === nextEdit.index - 1 && lastEdit.value.type === "value" && nextEdit.value.type === "value" && lastEdit.elemId === lastEdit.opId && nextEdit.elemId === nextEdit.opId && opIdDelta(lastEdit.elemId, nextEdit.elemId, 1) && lastEdit.value.datatype === nextEdit.value.datatype && typeof lastEdit.value.value === typeof nextEdit.value.value) {
        lastEdit.action = "multi-insert";
        if (nextEdit.value.datatype) lastEdit.datatype = nextEdit.value.datatype;
        lastEdit.values = [lastEdit.value.value, nextEdit.value.value];
        delete lastEdit.value;
        delete lastEdit.opId;
      } else if (lastEdit.action === "multi-insert" && nextEdit.action === "insert" && lastEdit.index + lastEdit.values.length === nextEdit.index && nextEdit.value.type === "value" && nextEdit.elemId === nextEdit.opId && opIdDelta(lastEdit.elemId, nextEdit.elemId, lastEdit.values.length) && lastEdit.datatype === nextEdit.value.datatype && typeof lastEdit.values[0] === typeof nextEdit.value.value) {
        lastEdit.values.push(nextEdit.value.value);
      } else if (lastEdit.action === "remove" && nextEdit.action === "remove" && lastEdit.index === nextEdit.index) {
        lastEdit.count += nextEdit.count;
      } else {
        existingEdits.push(nextEdit);
      }
    }
    function appendUpdate(edits, index, elemId, opId, value, firstUpdate) {
      let insert = false;
      if (firstUpdate) {
        while (!insert && edits.length > 0) {
          const lastEdit = edits[edits.length - 1];
          if ((lastEdit.action === "insert" || lastEdit.action === "update") && lastEdit.index === index) {
            edits.pop();
            insert = lastEdit.action === "insert";
          } else if (lastEdit.action === "multi-insert" && lastEdit.index + lastEdit.values.length - 1 === index) {
            lastEdit.values.pop();
            insert = true;
          } else {
            break;
          }
        }
      }
      if (insert) {
        appendEdit(edits, { action: "insert", index, elemId, opId, value });
      } else {
        appendEdit(edits, { action: "update", index, opId, value });
      }
    }
    function convertInsertToUpdate(edits, index, elemId) {
      let updates = [];
      while (edits.length > 0) {
        let lastEdit = edits[edits.length - 1];
        if (lastEdit.action === "insert") {
          if (lastEdit.index !== index) throw new RangeError("last edit has unexpected index");
          updates.unshift(edits.pop());
          break;
        } else if (lastEdit.action === "update") {
          if (lastEdit.index !== index) throw new RangeError("last edit has unexpected index");
          updates.unshift(edits.pop());
        } else {
          throw new RangeError("last edit has unexpected action");
        }
      }
      let firstUpdate = true;
      for (let update of updates) {
        appendUpdate(edits, index, elemId, update.opId, update.value, firstUpdate);
        firstUpdate = false;
      }
    }
    function updatePatchProperty(patches, newBlock, objectId, op, docState, propState, listIndex, oldSuccNum) {
      const isWholeDoc = !newBlock;
      const type = op[actionIdx] < ACTIONS.length ? OBJECT_TYPE[ACTIONS[op[actionIdx]]] : null;
      const opId = `${op[idCtrIdx]}@${docState.actorIds[op[idActorIdx]]}`;
      const elemIdActor = op[insertIdx] ? op[idActorIdx] : op[keyActorIdx];
      const elemIdCtr = op[insertIdx] ? op[idCtrIdx] : op[keyCtrIdx];
      const elemId = op[keyStrIdx] ? op[keyStrIdx] : `${elemIdCtr}@${docState.actorIds[elemIdActor]}`;
      if (op[actionIdx] % 2 === 0 && !docState.objectMeta[opId]) {
        docState.objectMeta[opId] = { parentObj: objectId, parentKey: elemId, opId, type, children: {} };
        deepCopyUpdate(docState.objectMeta, [objectId, "children", elemId, opId], { objectId: opId, type, props: {} });
      }
      const firstOp = !propState[elemId];
      if (!propState[elemId]) propState[elemId] = { visibleOps: [], hasChild: false };
      const isOverwritten = oldSuccNum !== void 0 && op[succNumIdx] > 0;
      if (!isOverwritten) {
        propState[elemId].visibleOps.push(op);
        propState[elemId].hasChild = propState[elemId].hasChild || op[actionIdx] % 2 === 0;
      }
      const prevChildren = docState.objectMeta[objectId].children[elemId];
      if (propState[elemId].hasChild || prevChildren && Object.keys(prevChildren).length > 0) {
        let values = {};
        for (let visible of propState[elemId].visibleOps) {
          const opId2 = `${visible[idCtrIdx]}@${docState.actorIds[visible[idActorIdx]]}`;
          if (ACTIONS[visible[actionIdx]] === "set") {
            values[opId2] = Object.assign({ type: "value" }, decodeValue(visible[valLenIdx], visible[valRawIdx]));
          } else if (visible[actionIdx] % 2 === 0) {
            const objType = visible[actionIdx] < ACTIONS.length ? OBJECT_TYPE[ACTIONS[visible[actionIdx]]] : null;
            values[opId2] = emptyObjectPatch(opId2, objType);
          }
        }
        deepCopyUpdate(docState.objectMeta, [objectId, "children", elemId], values);
      }
      let patchKey, patchValue;
      if (isOverwritten && ACTIONS[op[actionIdx]] === "set" && (op[valLenIdx] & 15) === VALUE_TYPE.COUNTER) {
        if (!propState[elemId]) propState[elemId] = { visibleOps: [], hasChild: false };
        if (!propState[elemId].counterStates) propState[elemId].counterStates = {};
        let counterStates = propState[elemId].counterStates;
        let counterState = { opId, value: decodeValue(op[valLenIdx], op[valRawIdx]).value, succs: {} };
        for (let i = 0; i < op[succNumIdx]; i++) {
          const succOp = `${op[succCtrIdx][i]}@${docState.actorIds[op[succActorIdx][i]]}`;
          counterStates[succOp] = counterState;
          counterState.succs[succOp] = true;
        }
      } else if (ACTIONS[op[actionIdx]] === "inc") {
        if (!propState[elemId] || !propState[elemId].counterStates || !propState[elemId].counterStates[opId]) {
          throw new RangeError(`increment operation ${opId} for unknown counter`);
        }
        let counterState = propState[elemId].counterStates[opId];
        counterState.value += decodeValue(op[valLenIdx], op[valRawIdx]).value;
        delete counterState.succs[opId];
        if (Object.keys(counterState.succs).length === 0) {
          patchKey = counterState.opId;
          patchValue = { type: "value", datatype: "counter", value: counterState.value };
        }
      } else if (!isOverwritten) {
        if (ACTIONS[op[actionIdx]] === "set") {
          patchKey = opId;
          patchValue = Object.assign({ type: "value" }, decodeValue(op[valLenIdx], op[valRawIdx]));
        } else if (op[actionIdx] % 2 === 0) {
          if (!patches[opId]) patches[opId] = emptyObjectPatch(opId, type);
          patchKey = opId;
          patchValue = patches[opId];
        }
      }
      if (!patches[objectId]) patches[objectId] = emptyObjectPatch(objectId, docState.objectMeta[objectId].type);
      const patch = patches[objectId];
      if (op[keyStrIdx] === null) {
        if (oldSuccNum === 0 && !isWholeDoc && propState[elemId].action === "insert") {
          propState[elemId].action = "update";
          convertInsertToUpdate(patch.edits, listIndex, elemId);
          if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {
            newBlock.numVisible -= 1;
          }
        }
        if (patchValue) {
          if (!propState[elemId].action && (oldSuccNum === void 0 || isWholeDoc)) {
            propState[elemId].action = "insert";
            appendEdit(patch.edits, { action: "insert", index: listIndex, elemId, opId: patchKey, value: patchValue });
            if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {
              newBlock.numVisible += 1;
            }
          } else if (propState[elemId].action === "remove") {
            let lastEdit = patch.edits[patch.edits.length - 1];
            if (lastEdit.action !== "remove") throw new RangeError("last edit has unexpected type");
            if (lastEdit.count > 1) lastEdit.count -= 1;
            else patch.edits.pop();
            propState[elemId].action = "update";
            appendUpdate(patch.edits, listIndex, elemId, patchKey, patchValue, true);
            if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {
              newBlock.numVisible += 1;
            }
          } else {
            appendUpdate(patch.edits, listIndex, elemId, patchKey, patchValue, !propState[elemId].action);
            if (!propState[elemId].action) propState[elemId].action = "update";
          }
        } else if (oldSuccNum === 0 && !propState[elemId].action) {
          propState[elemId].action = "remove";
          appendEdit(patch.edits, { action: "remove", index: listIndex, count: 1 });
          if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {
            newBlock.numVisible -= 1;
          }
        }
      } else if (patchValue || !isWholeDoc) {
        if (firstOp || !patch.props[op[keyStrIdx]]) patch.props[op[keyStrIdx]] = {};
        if (patchValue) patch.props[op[keyStrIdx]][patchKey] = patchValue;
      }
    }
    function mergeDocChangeOps(patches, newBlock, outCols, changeState, docState, listIndex, blockIndex) {
      const firstOp = changeState.nextOp, insert = firstOp[insertIdx];
      const objActor = firstOp[objActorIdx], objCtr = firstOp[objCtrIdx];
      const objectId = objActor === null ? "_root" : `${objCtr}@${docState.actorIds[objActor]}`;
      const idActorIndex = changeState.actorIndex, idActor = docState.actorIds[idActorIndex];
      let foundListElem = false, elemVisible = false, propState = {}, docOp;
      ({ docOp, blockIndex } = readNextDocOp(docState, blockIndex));
      let docOpsConsumed = docOp === null ? 0 : 1;
      let docOpOldSuccNum = docOp === null ? 0 : docOp[succNumIdx];
      let changeOp = null, changeOps = [], changeCols = [], predSeen = [], lastChangeKey = null;
      changeState.objectIds.add(objectId);
      while (true) {
        if (changeOps.length === 0) {
          foundListElem = false;
          let nextOp = changeState.nextOp;
          while (!changeState.done && nextOp[idActorIdx] === idActorIndex && nextOp[insertIdx] === insert && nextOp[objActorIdx] === firstOp[objActorIdx] && nextOp[objCtrIdx] === firstOp[objCtrIdx]) {
            const lastOp = changeOps.length > 0 ? changeOps[changeOps.length - 1] : null;
            let isOverwrite = false;
            for (let i = 0; i < nextOp[predNumIdx]; i++) {
              for (let prevOp of changeOps) {
                if (nextOp[predActorIdx][i] === prevOp[idActorIdx] && nextOp[predCtrIdx][i] === prevOp[idCtrIdx]) {
                  isOverwrite = true;
                }
              }
            }
            if (nextOp === firstOp) {
            } else if (insert && lastOp !== null && nextOp[keyStrIdx] === null && nextOp[keyActorIdx] === lastOp[idActorIdx] && nextOp[keyCtrIdx] === lastOp[idCtrIdx]) {
            } else if (!insert && lastOp !== null && nextOp[keyStrIdx] !== null && nextOp[keyStrIdx] === lastOp[keyStrIdx] && !isOverwrite) {
            } else if (!insert && lastOp !== null && nextOp[keyStrIdx] === null && lastOp[keyStrIdx] === null && nextOp[keyActorIdx] === lastOp[keyActorIdx] && nextOp[keyCtrIdx] === lastOp[keyCtrIdx] && !isOverwrite) {
            } else if (!insert && lastOp === null && nextOp[keyStrIdx] === null && docOp && docOp[insertIdx] && docOp[keyStrIdx] === null && docOp[idActorIdx] === nextOp[keyActorIdx] && docOp[idCtrIdx] === nextOp[keyCtrIdx]) {
            } else if (!insert && lastOp === null && nextOp[keyStrIdx] !== null && lastChangeKey !== null && lastChangeKey < nextOp[keyStrIdx]) {
            } else break;
            lastChangeKey = nextOp !== null ? nextOp[keyStrIdx] : null;
            changeOps.push(changeState.nextOp);
            changeCols.push(changeState.columns);
            predSeen.push(new Array(changeState.nextOp[predNumIdx]));
            readNextChangeOp(docState, changeState);
            nextOp = changeState.nextOp;
          }
        }
        if (changeOps.length > 0) changeOp = changeOps[0];
        const inCorrectObject = docOp && docOp[objActorIdx] === changeOp[objActorIdx] && docOp[objCtrIdx] === changeOp[objCtrIdx];
        const keyMatches = docOp && docOp[keyStrIdx] !== null && docOp[keyStrIdx] === changeOp[keyStrIdx];
        const listElemMatches = docOp && docOp[keyStrIdx] === null && changeOp[keyStrIdx] === null && (!docOp[insertIdx] && docOp[keyActorIdx] === changeOp[keyActorIdx] && docOp[keyCtrIdx] === changeOp[keyCtrIdx] || docOp[insertIdx] && docOp[idActorIdx] === changeOp[keyActorIdx] && docOp[idCtrIdx] === changeOp[keyCtrIdx]);
        if (changeOps.length === 0 && !(inCorrectObject && (keyMatches || listElemMatches))) break;
        let takeDocOp = false, takeChangeOps = 0;
        if (insert || !inCorrectObject || docOp[keyStrIdx] === null && changeOp[keyStrIdx] !== null || docOp[keyStrIdx] !== null && changeOp[keyStrIdx] !== null && changeOp[keyStrIdx] < docOp[keyStrIdx]) {
          takeChangeOps = changeOps.length;
          if (!inCorrectObject && !foundListElem && changeOp[keyStrIdx] === null && !changeOp[insertIdx]) {
            throw new RangeError(`could not find list element with ID: ${changeOp[keyCtrIdx]}@${docState.actorIds[changeOp[keyActorIdx]]}`);
          }
        } else if (keyMatches || listElemMatches || foundListElem) {
          for (let opIndex = 0; opIndex < changeOps.length; opIndex++) {
            const op = changeOps[opIndex];
            for (let i = 0; i < op[predNumIdx]; i++) {
              if (op[predActorIdx][i] === docOp[idActorIdx] && op[predCtrIdx][i] === docOp[idCtrIdx]) {
                let j = 0;
                while (j < docOp[succNumIdx] && (docOp[succCtrIdx][j] < op[idCtrIdx] || docOp[succCtrIdx][j] === op[idCtrIdx] && docState.actorIds[docOp[succActorIdx][j]] < idActor)) j++;
                docOp[succCtrIdx].splice(j, 0, op[idCtrIdx]);
                docOp[succActorIdx].splice(j, 0, idActorIndex);
                docOp[succNumIdx]++;
                predSeen[opIndex][i] = true;
                break;
              }
            }
          }
          if (listElemMatches) foundListElem = true;
          if (foundListElem && !listElemMatches) {
            takeChangeOps = changeOps.length;
          } else if (changeOps.length === 0 || docOp[idCtrIdx] < changeOp[idCtrIdx] || docOp[idCtrIdx] === changeOp[idCtrIdx] && docState.actorIds[docOp[idActorIdx]] < idActor) {
            takeDocOp = true;
            updatePatchProperty(patches, newBlock, objectId, docOp, docState, propState, listIndex, docOpOldSuccNum);
            for (let i = changeOps.length - 1; i >= 0; i--) {
              let deleted = true;
              for (let j = 0; j < changeOps[i][predNumIdx]; j++) {
                if (!predSeen[i][j]) deleted = false;
              }
              if (ACTIONS[changeOps[i][actionIdx]] === "del" && deleted) {
                changeOps.splice(i, 1);
                changeCols.splice(i, 1);
                predSeen.splice(i, 1);
              }
            }
          } else if (docOp[idCtrIdx] === changeOp[idCtrIdx] && docState.actorIds[docOp[idActorIdx]] === idActor) {
            throw new RangeError(`duplicate operation ID: ${changeOp[idCtrIdx]}@${idActor}`);
          } else {
            takeChangeOps = 1;
          }
        } else {
          takeDocOp = true;
        }
        if (takeDocOp) {
          appendOperation(outCols, docState.blocks[blockIndex].columns, docOp);
          addBlockOperation(newBlock, docOp, docState.actorIds, false);
          if (docOp[insertIdx] && elemVisible) {
            elemVisible = false;
            listIndex++;
          }
          if (docOp[succNumIdx] === 0) elemVisible = true;
          newBlock.numOps++;
          ({ docOp, blockIndex } = readNextDocOp(docState, blockIndex));
          if (docOp !== null) {
            docOpsConsumed++;
            docOpOldSuccNum = docOp[succNumIdx];
          }
        }
        if (takeChangeOps > 0) {
          for (let i = 0; i < takeChangeOps; i++) {
            let op = changeOps[i];
            for (let j = 0; j < op[predNumIdx]; j++) {
              if (!predSeen[i][j]) {
                throw new RangeError(`no matching operation for pred: ${op[predCtrIdx][j]}@${docState.actorIds[op[predActorIdx][j]]}`);
              }
            }
            appendOperation(outCols, changeCols[i], op);
            addBlockOperation(newBlock, op, docState.actorIds, true);
            updatePatchProperty(patches, newBlock, objectId, op, docState, propState, listIndex);
            if (op[insertIdx]) {
              elemVisible = false;
              listIndex++;
            } else {
              elemVisible = true;
            }
          }
          if (takeChangeOps === changeOps.length) {
            changeOps.length = 0;
            changeCols.length = 0;
            predSeen.length = 0;
          } else {
            changeOps.splice(0, takeChangeOps);
            changeCols.splice(0, takeChangeOps);
            predSeen.splice(0, takeChangeOps);
          }
          newBlock.numOps += takeChangeOps;
        }
      }
      if (docOp) {
        appendOperation(outCols, docState.blocks[blockIndex].columns, docOp);
        newBlock.numOps++;
        addBlockOperation(newBlock, docOp, docState.actorIds, false);
      }
      return { docOpsConsumed, blockIndex };
    }
    function applyOps(patches, changeState, docState) {
      const [objActorNum, objCtr, keyActorNum, keyCtr, keyStr, idActorNum, idCtr, insert] = changeState.nextOp;
      const objActor = objActorNum === null ? null : docState.actorIds[objActorNum];
      const keyActor = keyActorNum === null ? null : docState.actorIds[keyActorNum];
      const ops = {
        objActor,
        objActorNum,
        objCtr,
        keyActor,
        keyActorNum,
        keyCtr,
        keyStr,
        idActor: docState.actorIds[idActorNum],
        idCtr,
        insert,
        objId: objActor === null ? "_root" : `${objCtr}@${objActor}`
      };
      const { blockIndex, skipCount, visibleCount } = seekToOp(docState, ops);
      const block = docState.blocks[blockIndex];
      for (let col of block.columns) col.decoder.reset();
      const resetFirstVisible = skipCount === 0 || block.firstVisibleActor === void 0 || !insert && block.firstVisibleActor === keyActorNum && block.firstVisibleCtr === keyCtr;
      const newBlock = {
        columns: void 0,
        bloom: new Uint8Array(block.bloom),
        numOps: skipCount,
        lastKey: block.lastKey,
        numVisible: block.numVisible,
        lastObjectActor: block.lastObjectActor,
        lastObjectCtr: block.lastObjectCtr,
        firstVisibleActor: resetFirstVisible ? void 0 : block.firstVisibleActor,
        firstVisibleCtr: resetFirstVisible ? void 0 : block.firstVisibleCtr,
        lastVisibleActor: void 0,
        lastVisibleCtr: void 0
      };
      const outCols = block.columns.map((col) => ({ columnId: col.columnId, encoder: encoderByColumnId(col.columnId) }));
      copyColumns(outCols, block.columns, skipCount);
      const { blockIndex: lastBlockIndex, docOpsConsumed } = mergeDocChangeOps(patches, newBlock, outCols, changeState, docState, visibleCount, blockIndex);
      const lastBlock = docState.blocks[lastBlockIndex];
      let copyAfterMerge = -skipCount - docOpsConsumed;
      for (let i = blockIndex; i <= lastBlockIndex; i++) copyAfterMerge += docState.blocks[i].numOps;
      copyColumns(outCols, lastBlock.columns, copyAfterMerge);
      newBlock.numOps += copyAfterMerge;
      for (let col of lastBlock.columns) {
        if (!col.decoder.done) throw new RangeError(`excess ops in column ${col.columnId}`);
      }
      newBlock.columns = outCols.map((col) => {
        const decoder = decoderByColumnId(col.columnId, col.encoder.buffer);
        return { columnId: col.columnId, decoder };
      });
      if (blockIndex === lastBlockIndex && newBlock.numOps <= MAX_BLOCK_SIZE) {
        if (copyAfterMerge > 0 && block.lastVisibleActor !== void 0 && block.lastVisibleCtr !== void 0) {
          newBlock.lastVisibleActor = block.lastVisibleActor;
          newBlock.lastVisibleCtr = block.lastVisibleCtr;
        }
        docState.blocks[blockIndex] = newBlock;
      } else {
        const newBlocks = splitBlock(newBlock);
        docState.blocks.splice(blockIndex, lastBlockIndex - blockIndex + 1, ...newBlocks);
      }
    }
    function updateBlockColumns(docState, changeCols) {
      if (changeCols[objActorIdx].columnId !== CHANGE_COLUMNS[objActorIdx].columnId || CHANGE_COLUMNS[objActorIdx].columnName !== "objActor" || changeCols[objCtrIdx].columnId !== CHANGE_COLUMNS[objCtrIdx].columnId || CHANGE_COLUMNS[objCtrIdx].columnName !== "objCtr" || changeCols[keyActorIdx].columnId !== CHANGE_COLUMNS[keyActorIdx].columnId || CHANGE_COLUMNS[keyActorIdx].columnName !== "keyActor" || changeCols[keyCtrIdx].columnId !== CHANGE_COLUMNS[keyCtrIdx].columnId || CHANGE_COLUMNS[keyCtrIdx].columnName !== "keyCtr" || changeCols[keyStrIdx].columnId !== CHANGE_COLUMNS[keyStrIdx].columnId || CHANGE_COLUMNS[keyStrIdx].columnName !== "keyStr" || changeCols[idActorIdx].columnId !== CHANGE_COLUMNS[idActorIdx].columnId || CHANGE_COLUMNS[idActorIdx].columnName !== "idActor" || changeCols[idCtrIdx].columnId !== CHANGE_COLUMNS[idCtrIdx].columnId || CHANGE_COLUMNS[idCtrIdx].columnName !== "idCtr" || changeCols[insertIdx].columnId !== CHANGE_COLUMNS[insertIdx].columnId || CHANGE_COLUMNS[insertIdx].columnName !== "insert" || changeCols[actionIdx].columnId !== CHANGE_COLUMNS[actionIdx].columnId || CHANGE_COLUMNS[actionIdx].columnName !== "action" || changeCols[valLenIdx].columnId !== CHANGE_COLUMNS[valLenIdx].columnId || CHANGE_COLUMNS[valLenIdx].columnName !== "valLen" || changeCols[valRawIdx].columnId !== CHANGE_COLUMNS[valRawIdx].columnId || CHANGE_COLUMNS[valRawIdx].columnName !== "valRaw" || changeCols[predNumIdx].columnId !== CHANGE_COLUMNS[predNumIdx].columnId || CHANGE_COLUMNS[predNumIdx].columnName !== "predNum" || changeCols[predActorIdx].columnId !== CHANGE_COLUMNS[predActorIdx].columnId || CHANGE_COLUMNS[predActorIdx].columnName !== "predActor" || changeCols[predCtrIdx].columnId !== CHANGE_COLUMNS[predCtrIdx].columnId || CHANGE_COLUMNS[predCtrIdx].columnName !== "predCtr") {
        throw new RangeError("unexpected columnId");
      }
      const docCols = docState.blocks[0].columns;
      if (!changeCols.every((changeCol) => PRED_COLUMN_IDS.includes(changeCol.columnId) || docCols.find((docCol) => docCol.columnId === changeCol.columnId))) {
        let allCols = docCols.map((docCol) => ({ columnId: docCol.columnId }));
        for (let changeCol of changeCols) {
          const { columnId } = changeCol;
          if (!PRED_COLUMN_IDS.includes(columnId) && !docCols.find((docCol) => docCol.columnId === columnId)) {
            allCols.push({ columnId });
          }
        }
        allCols.sort((a, b) => a.columnId - b.columnId);
        for (let blockIndex = 0; blockIndex < docState.blocks.length; blockIndex++) {
          let block = copyObject(docState.blocks[blockIndex]);
          block.columns = makeDecoders(block.columns.map((col) => ({ columnId: col.columnId, buffer: col.decoder.buf })), allCols);
          docState.blocks[blockIndex] = block;
        }
      }
    }
    function getActorTable(actorIds, change) {
      if (actorIds.indexOf(change.actorIds[0]) < 0) {
        if (change.seq !== 1) {
          throw new RangeError(`Seq ${change.seq} is the first change for actor ${change.actorIds[0]}`);
        }
        actorIds = actorIds.concat([change.actorIds[0]]);
      }
      const actorTable = [];
      for (let actorId of change.actorIds) {
        const index = actorIds.indexOf(actorId);
        if (index < 0) {
          throw new RangeError(`actorId ${actorId} is not known to document`);
        }
        actorTable.push(index);
      }
      return { actorIds, actorTable };
    }
    function setupPatches(patches, objectIds, docState) {
      for (let objectId of objectIds) {
        let meta = docState.objectMeta[objectId], childMeta = null, patchExists = false;
        while (true) {
          const hasChildren = childMeta && Object.keys(meta.children[childMeta.parentKey]).length > 0;
          if (!patches[objectId]) patches[objectId] = emptyObjectPatch(objectId, meta.type);
          if (childMeta && hasChildren) {
            if (meta.type === "list" || meta.type === "text") {
              for (let edit of patches[objectId].edits) {
                if (edit.opId && meta.children[childMeta.parentKey][edit.opId]) {
                  patchExists = true;
                }
              }
              if (!patchExists) {
                const obj = parseOpId(objectId), elem = parseOpId(childMeta.parentKey);
                const seekPos = {
                  objActor: obj.actorId,
                  objCtr: obj.counter,
                  keyActor: elem.actorId,
                  keyCtr: elem.counter,
                  objActorNum: docState.actorIds.indexOf(obj.actorId),
                  keyActorNum: docState.actorIds.indexOf(elem.actorId),
                  keyStr: null,
                  insert: false,
                  objId: objectId
                };
                const { visibleCount } = seekToOp(docState, seekPos);
                for (let [opId, value] of Object.entries(meta.children[childMeta.parentKey])) {
                  let patchValue = value;
                  if (value.objectId) {
                    if (!patches[value.objectId]) patches[value.objectId] = emptyObjectPatch(value.objectId, value.type);
                    patchValue = patches[value.objectId];
                  }
                  const edit = { action: "update", index: visibleCount, opId, value: patchValue };
                  appendEdit(patches[objectId].edits, edit);
                }
              }
            } else {
              if (!patches[objectId].props[childMeta.parentKey]) {
                patches[objectId].props[childMeta.parentKey] = {};
              }
              let values = patches[objectId].props[childMeta.parentKey];
              for (let [opId, value] of Object.entries(meta.children[childMeta.parentKey])) {
                if (values[opId]) {
                  patchExists = true;
                } else if (value.objectId) {
                  if (!patches[value.objectId]) patches[value.objectId] = emptyObjectPatch(value.objectId, value.type);
                  values[opId] = patches[value.objectId];
                } else {
                  values[opId] = value;
                }
              }
            }
          }
          if (patchExists || !meta.parentObj || childMeta && !hasChildren) break;
          childMeta = meta;
          objectId = meta.parentObj;
          meta = docState.objectMeta[objectId];
        }
      }
      return patches;
    }
    function applyChanges(patches, decodedChanges, docState, objectIds, throwExceptions) {
      let heads = new Set(docState.heads), changeHashes = /* @__PURE__ */ new Set();
      let clock = copyObject(docState.clock);
      let applied = [], enqueued = [];
      for (let change of decodedChanges) {
        if (docState.changeIndexByHash[change.hash] !== void 0 || changeHashes.has(change.hash)) continue;
        const expectedSeq = (clock[change.actor] || 0) + 1;
        let causallyReady = true;
        for (let dep of change.deps) {
          const depIndex = docState.changeIndexByHash[dep];
          if ((depIndex === void 0 || depIndex === -1) && !changeHashes.has(dep)) {
            causallyReady = false;
          }
        }
        if (!causallyReady) {
          enqueued.push(change);
        } else if (change.seq < expectedSeq) {
          if (throwExceptions) {
            throw new RangeError(`Reuse of sequence number ${change.seq} for actor ${change.actor}`);
          } else {
            return [[], decodedChanges];
          }
        } else if (change.seq > expectedSeq) {
          throw new RangeError(`Skipped sequence number ${expectedSeq} for actor ${change.actor}`);
        } else {
          clock[change.actor] = change.seq;
          changeHashes.add(change.hash);
          for (let dep of change.deps) heads.delete(dep);
          heads.add(change.hash);
          applied.push(change);
        }
      }
      if (applied.length > 0) {
        let changeState = { changes: applied, changeIndex: -1, objectIds };
        readNextChangeOp(docState, changeState);
        while (!changeState.done) applyOps(patches, changeState, docState);
        docState.heads = [...heads].sort();
        docState.clock = clock;
      }
      return [applied, enqueued];
    }
    function documentPatch(docState) {
      for (let col of docState.blocks[0].columns) col.decoder.reset();
      let propState = {}, docOp = null, blockIndex = 0;
      let patches = { _root: { objectId: "_root", type: "map", props: {} } };
      let lastObjActor = null, lastObjCtr = null, objectId = "_root", elemVisible = false, listIndex = 0;
      while (true) {
        ({ docOp, blockIndex } = readNextDocOp(docState, blockIndex));
        if (docOp === null) break;
        if (docOp[objActorIdx] !== lastObjActor || docOp[objCtrIdx] !== lastObjCtr) {
          objectId = `${docOp[objCtrIdx]}@${docState.actorIds[docOp[objActorIdx]]}`;
          lastObjActor = docOp[objActorIdx];
          lastObjCtr = docOp[objCtrIdx];
          propState = {};
          listIndex = 0;
          elemVisible = false;
        }
        if (docOp[insertIdx] && elemVisible) {
          elemVisible = false;
          listIndex++;
        }
        if (docOp[succNumIdx] === 0) elemVisible = true;
        if (docOp[idCtrIdx] > docState.maxOp) docState.maxOp = docOp[idCtrIdx];
        for (let i = 0; i < docOp[succNumIdx]; i++) {
          if (docOp[succCtrIdx][i] > docState.maxOp) docState.maxOp = docOp[succCtrIdx][i];
        }
        updatePatchProperty(patches, null, objectId, docOp, docState, propState, listIndex, docOp[succNumIdx]);
      }
      return patches._root;
    }
    function readDocumentChanges(doc) {
      const columns = makeDecoders(doc.changesColumns, DOCUMENT_COLUMNS);
      const actorD = columns[0].decoder, seqD = columns[1].decoder;
      const depsNumD = columns[5].decoder, depsIndexD = columns[6].decoder;
      if (columns[0].columnId !== DOCUMENT_COLUMNS[0].columnId || DOCUMENT_COLUMNS[0].columnName !== "actor" || columns[1].columnId !== DOCUMENT_COLUMNS[1].columnId || DOCUMENT_COLUMNS[1].columnName !== "seq" || columns[5].columnId !== DOCUMENT_COLUMNS[5].columnId || DOCUMENT_COLUMNS[5].columnName !== "depsNum" || columns[6].columnId !== DOCUMENT_COLUMNS[6].columnId || DOCUMENT_COLUMNS[6].columnName !== "depsIndex") {
        throw new RangeError("unexpected columnId");
      }
      let numChanges = 0, clock = {}, actorNums = [], headIndexes = /* @__PURE__ */ new Set();
      while (!actorD.done) {
        const actorNum = actorD.readValue(), seq = seqD.readValue(), depsNum = depsNumD.readValue();
        const actorId = doc.actorIds[actorNum];
        if (seq !== 1 && seq !== clock[actorId] + 1) {
          throw new RangeError(`Expected seq ${clock[actorId] + 1}, got ${seq} for actor ${actorId}`);
        }
        actorNums.push(actorNum);
        clock[actorId] = seq;
        headIndexes.add(numChanges);
        for (let j = 0; j < depsNum; j++) headIndexes.delete(depsIndexD.readValue());
        numChanges++;
      }
      const headActors = [...headIndexes].map((index) => doc.actorIds[actorNums[index]]).sort();
      for (let col of columns) col.decoder.reset();
      const encoders = columns.map((col) => ({ columnId: col.columnId, encoder: encoderByColumnId(col.columnId) }));
      copyColumns(encoders, columns, numChanges);
      return { clock, headActors, encoders, numChanges };
    }
    function appendChange(columns, change, actorIds, changeIndexByHash) {
      appendOperation(columns, DOCUMENT_COLUMNS, [
        actorIds.indexOf(change.actor),
        // actor
        change.seq,
        // seq
        change.maxOp,
        // maxOp
        change.time,
        // time
        change.message,
        // message
        change.deps.length,
        // depsNum
        change.deps.map((dep) => changeIndexByHash[dep]),
        // depsIndex
        change.extraBytes ? change.extraBytes.byteLength << 4 | VALUE_TYPE.BYTES : VALUE_TYPE.BYTES,
        // extraLen
        change.extraBytes
        // extraRaw
      ]);
    }
    var BackendDoc = class _BackendDoc {
      constructor(buffer) {
        this.maxOp = 0;
        this.haveHashGraph = false;
        this.changes = [];
        this.changeIndexByHash = {};
        this.dependenciesByHash = {};
        this.dependentsByHash = {};
        this.hashesByActor = {};
        this.actorIds = [];
        this.heads = [];
        this.clock = {};
        this.queue = [];
        this.objectMeta = { _root: { parentObj: null, parentKey: null, opId: null, type: "map", children: {} } };
        if (buffer) {
          const doc = decodeDocumentHeader(buffer);
          const { clock, headActors, encoders, numChanges } = readDocumentChanges(doc);
          this.binaryDoc = buffer;
          this.changes = new Array(numChanges);
          this.actorIds = doc.actorIds;
          this.heads = doc.heads;
          this.clock = clock;
          this.changesEncoders = encoders;
          this.extraBytes = doc.extraBytes;
          if (doc.heads.length === 1 && headActors.length === 1) {
            this.hashesByActor[headActors[0]] = [];
            this.hashesByActor[headActors[0]][clock[headActors[0]] - 1] = doc.heads[0];
          }
          if (doc.heads.length === doc.headsIndexes.length) {
            for (let i = 0; i < doc.heads.length; i++) {
              this.changeIndexByHash[doc.heads[i]] = doc.headsIndexes[i];
            }
          } else if (doc.heads.length === 1) {
            this.changeIndexByHash[doc.heads[0]] = numChanges - 1;
          } else {
            for (let head of doc.heads) this.changeIndexByHash[head] = -1;
          }
          this.blocks = [{ columns: makeDecoders(doc.opsColumns, DOC_OPS_COLUMNS) }];
          updateBlockMetadata(this.blocks[0]);
          if (this.blocks[0].numOps > MAX_BLOCK_SIZE) {
            this.blocks = splitBlock(this.blocks[0]);
          }
          let docState = { blocks: this.blocks, actorIds: this.actorIds, objectMeta: this.objectMeta, maxOp: 0 };
          this.initPatch = documentPatch(docState);
          this.maxOp = docState.maxOp;
        } else {
          this.haveHashGraph = true;
          this.changesEncoders = DOCUMENT_COLUMNS.map((col) => ({ columnId: col.columnId, encoder: encoderByColumnId(col.columnId) }));
          this.blocks = [{
            columns: makeDecoders([], DOC_OPS_COLUMNS),
            bloom: new Uint8Array(BLOOM_FILTER_SIZE),
            numOps: 0,
            lastKey: void 0,
            numVisible: void 0,
            lastObjectActor: void 0,
            lastObjectCtr: void 0,
            firstVisibleActor: void 0,
            firstVisibleCtr: void 0,
            lastVisibleActor: void 0,
            lastVisibleCtr: void 0
          }];
        }
      }
      /**
       * Makes a copy of this BackendDoc that can be independently modified.
       */
      clone() {
        let copy = new _BackendDoc();
        copy.maxOp = this.maxOp;
        copy.haveHashGraph = this.haveHashGraph;
        copy.changes = this.changes.slice();
        copy.changeIndexByHash = copyObject(this.changeIndexByHash);
        copy.dependenciesByHash = copyObject(this.dependenciesByHash);
        copy.dependentsByHash = Object.entries(this.dependentsByHash).reduce((acc, [k, v]) => {
          acc[k] = v.slice();
          return acc;
        }, {});
        copy.hashesByActor = Object.entries(this.hashesByActor).reduce((acc, [k, v]) => {
          acc[k] = v.slice();
          return acc;
        }, {});
        copy.actorIds = this.actorIds;
        copy.heads = this.heads;
        copy.clock = this.clock;
        copy.blocks = this.blocks;
        copy.objectMeta = this.objectMeta;
        copy.queue = this.queue;
        return copy;
      }
      /**
       * Parses the changes given as Uint8Arrays in `changeBuffers`, and applies them to the current
       * document. Returns a patch to apply to the frontend. If an exception is thrown, the document
       * object is not modified.
       */
      applyChanges(changeBuffers, isLocal = false) {
        let decodedChanges = changeBuffers.map((buffer) => {
          const decoded = decodeChangeColumns(buffer);
          decoded.buffer = buffer;
          return decoded;
        });
        let patches = { _root: { objectId: "_root", type: "map", props: {} } };
        let docState = {
          maxOp: this.maxOp,
          changeIndexByHash: this.changeIndexByHash,
          actorIds: this.actorIds,
          heads: this.heads,
          clock: this.clock,
          blocks: this.blocks.slice(),
          objectMeta: Object.assign({}, this.objectMeta)
        };
        let queue = this.queue.length === 0 ? decodedChanges : decodedChanges.concat(this.queue);
        let allApplied = [], objectIds = /* @__PURE__ */ new Set();
        while (true) {
          const [applied, enqueued] = applyChanges(patches, queue, docState, objectIds, this.haveHashGraph);
          queue = enqueued;
          for (let i = 0; i < applied.length; i++) {
            docState.changeIndexByHash[applied[i].hash] = this.changes.length + allApplied.length + i;
          }
          if (applied.length > 0) allApplied = allApplied.concat(applied);
          if (queue.length === 0) break;
          if (applied.length === 0) {
            if (this.haveHashGraph) break;
            this.computeHashGraph();
            docState.changeIndexByHash = this.changeIndexByHash;
          }
        }
        setupPatches(patches, objectIds, docState);
        for (let change of allApplied) {
          this.changes.push(change.buffer);
          if (!this.hashesByActor[change.actor]) this.hashesByActor[change.actor] = [];
          this.hashesByActor[change.actor][change.seq - 1] = change.hash;
          this.changeIndexByHash[change.hash] = this.changes.length - 1;
          this.dependenciesByHash[change.hash] = change.deps;
          this.dependentsByHash[change.hash] = [];
          for (let dep of change.deps) {
            if (!this.dependentsByHash[dep]) this.dependentsByHash[dep] = [];
            this.dependentsByHash[dep].push(change.hash);
          }
          appendChange(this.changesEncoders, change, docState.actorIds, this.changeIndexByHash);
        }
        this.maxOp = docState.maxOp;
        this.actorIds = docState.actorIds;
        this.heads = docState.heads;
        this.clock = docState.clock;
        this.blocks = docState.blocks;
        this.objectMeta = docState.objectMeta;
        this.queue = queue;
        this.binaryDoc = null;
        this.initPatch = null;
        let patch = {
          maxOp: this.maxOp,
          clock: this.clock,
          deps: this.heads,
          pendingChanges: this.queue.length,
          diffs: patches._root
        };
        if (isLocal && decodedChanges.length === 1) {
          patch.actor = decodedChanges[0].actor;
          patch.seq = decodedChanges[0].seq;
        }
        return patch;
      }
      /**
       * Reconstructs the full change history of a document, and initialises the variables that allow us
       * to traverse the hash graph of changes and their dependencies. When a compressed document is
       * loaded we defer the computation of this hash graph to make loading faster, but if the hash
       * graph is later needed (e.g. for the sync protocol), this function fills it in.
       */
      computeHashGraph() {
        const binaryDoc = this.save();
        this.haveHashGraph = true;
        this.changes = [];
        this.changeIndexByHash = {};
        this.dependenciesByHash = {};
        this.dependentsByHash = {};
        this.hashesByActor = {};
        this.clock = {};
        for (let change of decodeChanges([binaryDoc])) {
          const binaryChange = encodeChange(change);
          this.changes.push(binaryChange);
          this.changeIndexByHash[change.hash] = this.changes.length - 1;
          this.dependenciesByHash[change.hash] = change.deps;
          this.dependentsByHash[change.hash] = [];
          for (let dep of change.deps) this.dependentsByHash[dep].push(change.hash);
          if (change.seq === 1) this.hashesByActor[change.actor] = [];
          this.hashesByActor[change.actor].push(change.hash);
          const expectedSeq = (this.clock[change.actor] || 0) + 1;
          if (change.seq !== expectedSeq) {
            throw new RangeError(`Expected seq ${expectedSeq}, got seq ${change.seq} from actor ${change.actor}`);
          }
          this.clock[change.actor] = change.seq;
        }
      }
      /**
       * Returns all the changes that need to be sent to another replica. `haveDeps` is a list of change
       * hashes (as hex strings) of the heads that the other replica has. The changes in `haveDeps` and
       * any of their transitive dependencies will not be returned; any changes later than or concurrent
       * to the hashes in `haveDeps` will be returned. If `haveDeps` is an empty array, all changes are
       * returned. Throws an exception if any of the given hashes are not known to this replica.
       */
      getChanges(haveDeps) {
        if (!this.haveHashGraph) this.computeHashGraph();
        if (haveDeps.length === 0) {
          return this.changes.slice();
        }
        let stack = [], seenHashes = {}, toReturn = [];
        for (let hash of haveDeps) {
          seenHashes[hash] = true;
          const successors = this.dependentsByHash[hash];
          if (!successors) throw new RangeError(`hash not found: ${hash}`);
          stack.push(...successors);
        }
        while (stack.length > 0) {
          const hash = stack.pop();
          seenHashes[hash] = true;
          toReturn.push(hash);
          if (!this.dependenciesByHash[hash].every((dep) => seenHashes[dep])) {
            break;
          }
          stack.push(...this.dependentsByHash[hash]);
        }
        if (stack.length === 0 && this.heads.every((head) => seenHashes[head])) {
          return toReturn.map((hash) => this.changes[this.changeIndexByHash[hash]]);
        }
        stack = haveDeps.slice();
        seenHashes = {};
        while (stack.length > 0) {
          const hash = stack.pop();
          if (!seenHashes[hash]) {
            const deps = this.dependenciesByHash[hash];
            if (!deps) throw new RangeError(`hash not found: ${hash}`);
            stack.push(...deps);
            seenHashes[hash] = true;
          }
        }
        return this.changes.filter((change) => !seenHashes[decodeChangeMeta(change, true).hash]);
      }
      /**
       * Returns all changes that are present in this BackendDoc, but not present in the `other`
       * BackendDoc.
       */
      getChangesAdded(other) {
        if (!this.haveHashGraph) this.computeHashGraph();
        let stack = this.heads.slice(), seenHashes = {}, toReturn = [];
        while (stack.length > 0) {
          const hash = stack.pop();
          if (!seenHashes[hash] && other.changeIndexByHash[hash] === void 0) {
            seenHashes[hash] = true;
            toReturn.push(hash);
            stack.push(...this.dependenciesByHash[hash]);
          }
        }
        return toReturn.reverse().map((hash) => this.changes[this.changeIndexByHash[hash]]);
      }
      getChangeByHash(hash) {
        if (!this.haveHashGraph) this.computeHashGraph();
        return this.changes[this.changeIndexByHash[hash]];
      }
      /**
       * Returns the hashes of any missing dependencies, i.e. where we have tried to apply a change that
       * has a dependency on a change we have not seen.
       *
       * If the argument `heads` is given (an array of hexadecimal strings representing hashes as
       * returned by `getHeads()`), this function also ensures that all of those hashes resolve to
       * either a change that has been applied to the document, or that has been enqueued for later
       * application once missing dependencies have arrived. Any missing heads hashes are included in
       * the returned array.
       */
      getMissingDeps(heads = []) {
        if (!this.haveHashGraph) this.computeHashGraph();
        let allDeps = new Set(heads), inQueue = /* @__PURE__ */ new Set();
        for (let change of this.queue) {
          inQueue.add(change.hash);
          for (let dep of change.deps) allDeps.add(dep);
        }
        let missing = [];
        for (let hash of allDeps) {
          if (this.changeIndexByHash[hash] === void 0 && !inQueue.has(hash)) missing.push(hash);
        }
        return missing.sort();
      }
      /**
       * Serialises the current document state into a single byte array.
       */
      save() {
        if (this.binaryDoc) return this.binaryDoc;
        const newEncoders = this.changesEncoders.map((col) => ({ columnId: col.columnId, encoder: encoderByColumnId(col.columnId) }));
        const decoders = this.changesEncoders.map((col) => {
          const decoder = decoderByColumnId(col.columnId, col.encoder.buffer);
          return { columnId: col.columnId, decoder };
        });
        copyColumns(newEncoders, decoders, this.changes.length);
        this.binaryDoc = encodeDocumentHeader({
          changesColumns: this.changesEncoders,
          opsColumns: concatBlocks(this.blocks),
          actorIds: this.actorIds,
          // TODO: sort actorIds (requires transforming all actorId columns in opsColumns)
          heads: this.heads,
          headsIndexes: this.heads.map((hash) => this.changeIndexByHash[hash]),
          extraBytes: this.extraBytes
        });
        this.changesEncoders = newEncoders;
        return this.binaryDoc;
      }
      /**
       * Returns a patch from which we can initialise the current state of the backend.
       */
      getPatch() {
        const objectMeta = { _root: { parentObj: null, parentKey: null, opId: null, type: "map", children: {} } };
        const docState = { blocks: this.blocks, actorIds: this.actorIds, objectMeta, maxOp: 0 };
        const diffs = this.initPatch ? this.initPatch : documentPatch(docState);
        return {
          maxOp: this.maxOp,
          clock: this.clock,
          deps: this.heads,
          pendingChanges: this.queue.length,
          diffs
        };
      }
    };
    module.exports = { MAX_BLOCK_SIZE, BackendDoc, bloomFilterContains };
  }
});

// node_modules/automerge/backend/util.js
var require_util = __commonJS({
  "node_modules/automerge/backend/util.js"(exports, module) {
    function backendState(backend) {
      if (backend.frozen) {
        throw new Error(
          "Attempting to use an outdated Automerge document that has already been updated. Please use the latest document state, or call Automerge.clone() if you really need to use this old document state."
        );
      }
      return backend.state;
    }
    module.exports = {
      backendState
    };
  }
});

// node_modules/automerge/backend/backend.js
var require_backend = __commonJS({
  "node_modules/automerge/backend/backend.js"(exports, module) {
    var { encodeChange } = require_columnar();
    var { BackendDoc } = require_new();
    var { backendState } = require_util();
    function init() {
      return { state: new BackendDoc(), heads: [] };
    }
    function clone(backend) {
      return { state: backendState(backend).clone(), heads: backend.heads };
    }
    function free(backend) {
      backend.state = null;
      backend.frozen = true;
    }
    function applyChanges(backend, changes) {
      const state = backendState(backend);
      const patch = state.applyChanges(changes);
      backend.frozen = true;
      return [{ state, heads: state.heads }, patch];
    }
    function hashByActor(state, actorId, index) {
      if (state.hashesByActor[actorId] && state.hashesByActor[actorId][index]) {
        return state.hashesByActor[actorId][index];
      }
      if (!state.haveHashGraph) {
        state.computeHashGraph();
        if (state.hashesByActor[actorId] && state.hashesByActor[actorId][index]) {
          return state.hashesByActor[actorId][index];
        }
      }
      throw new RangeError(`Unknown change: actorId = ${actorId}, seq = ${index + 1}`);
    }
    function applyLocalChange(backend, change) {
      const state = backendState(backend);
      if (change.seq <= state.clock[change.actor] || 0) {
        throw new RangeError("Change request has already been applied");
      }
      if (change.seq > 1) {
        const lastHash2 = hashByActor(state, change.actor, change.seq - 2);
        if (!lastHash2) {
          throw new RangeError(`Cannot find hash of localChange before seq=${change.seq}`);
        }
        let deps = { [lastHash2]: true };
        for (let hash of change.deps) deps[hash] = true;
        change.deps = Object.keys(deps).sort();
      }
      const binaryChange = encodeChange(change);
      const patch = state.applyChanges([binaryChange], true);
      backend.frozen = true;
      const lastHash = hashByActor(state, change.actor, change.seq - 1);
      patch.deps = patch.deps.filter((head) => head !== lastHash);
      return [{ state, heads: state.heads }, patch, binaryChange];
    }
    function save(backend) {
      return backendState(backend).save();
    }
    function load(data) {
      const state = new BackendDoc(data);
      return { state, heads: state.heads };
    }
    function loadChanges(backend, changes) {
      const state = backendState(backend);
      state.applyChanges(changes);
      backend.frozen = true;
      return { state, heads: state.heads };
    }
    function getPatch(backend) {
      return backendState(backend).getPatch();
    }
    function getHeads(backend) {
      return backend.heads;
    }
    function getAllChanges(backend) {
      return getChanges(backend, []);
    }
    function getChanges(backend, haveDeps) {
      if (!Array.isArray(haveDeps)) {
        throw new TypeError("Pass an array of hashes to Backend.getChanges()");
      }
      return backendState(backend).getChanges(haveDeps);
    }
    function getChangesAdded(backend1, backend2) {
      return backendState(backend2).getChangesAdded(backendState(backend1));
    }
    function getChangeByHash(backend, hash) {
      return backendState(backend).getChangeByHash(hash);
    }
    function getMissingDeps(backend, heads = []) {
      return backendState(backend).getMissingDeps(heads);
    }
    module.exports = {
      init,
      clone,
      free,
      applyChanges,
      applyLocalChange,
      save,
      load,
      loadChanges,
      getPatch,
      getHeads,
      getAllChanges,
      getChanges,
      getChangesAdded,
      getChangeByHash,
      getMissingDeps
    };
  }
});

// node_modules/automerge/backend/sync.js
var require_sync = __commonJS({
  "node_modules/automerge/backend/sync.js"(exports, module) {
    var Backend = require_backend();
    var { hexStringToBytes, bytesToHexString, Encoder, Decoder } = require_encoding();
    var { decodeChangeMeta } = require_columnar();
    var { copyObject } = require_common();
    var HASH_SIZE = 32;
    var MESSAGE_TYPE_SYNC = 66;
    var PEER_STATE_TYPE = 67;
    var BITS_PER_ENTRY = 10;
    var NUM_PROBES = 7;
    var BloomFilter = class {
      constructor(arg) {
        if (Array.isArray(arg)) {
          this.numEntries = arg.length;
          this.numBitsPerEntry = BITS_PER_ENTRY;
          this.numProbes = NUM_PROBES;
          this.bits = new Uint8Array(Math.ceil(this.numEntries * this.numBitsPerEntry / 8));
          for (let hash of arg) this.addHash(hash);
        } else if (arg instanceof Uint8Array) {
          if (arg.byteLength === 0) {
            this.numEntries = 0;
            this.numBitsPerEntry = 0;
            this.numProbes = 0;
            this.bits = arg;
          } else {
            const decoder = new Decoder(arg);
            this.numEntries = decoder.readUint32();
            this.numBitsPerEntry = decoder.readUint32();
            this.numProbes = decoder.readUint32();
            this.bits = decoder.readRawBytes(Math.ceil(this.numEntries * this.numBitsPerEntry / 8));
          }
        } else {
          throw new TypeError("invalid argument");
        }
      }
      /**
       * Returns the Bloom filter state, encoded as a byte array.
       */
      get bytes() {
        if (this.numEntries === 0) return new Uint8Array(0);
        const encoder = new Encoder();
        encoder.appendUint32(this.numEntries);
        encoder.appendUint32(this.numBitsPerEntry);
        encoder.appendUint32(this.numProbes);
        encoder.appendRawBytes(this.bits);
        return encoder.buffer;
      }
      /**
       * Given a SHA-256 hash (as hex string), returns an array of probe indexes indicating which bits
       * in the Bloom filter need to be tested or set for this particular entry. We do this by
       * interpreting the first 12 bytes of the hash as three little-endian 32-bit unsigned integers,
       * and then using triple hashing to compute the probe indexes. The algorithm comes from:
       *
       * Peter C. Dillinger and Panagiotis Manolios. Bloom Filters in Probabilistic Verification.
       * 5th International Conference on Formal Methods in Computer-Aided Design (FMCAD), November 2004.
       * http://www.ccis.northeastern.edu/home/pete/pub/bloom-filters-verification.pdf
       */
      getProbes(hash) {
        const hashBytes = hexStringToBytes(hash), modulo = 8 * this.bits.byteLength;
        if (hashBytes.byteLength !== 32) throw new RangeError(`Not a 256-bit hash: ${hash}`);
        let x = ((hashBytes[0] | hashBytes[1] << 8 | hashBytes[2] << 16 | hashBytes[3] << 24) >>> 0) % modulo;
        let y = ((hashBytes[4] | hashBytes[5] << 8 | hashBytes[6] << 16 | hashBytes[7] << 24) >>> 0) % modulo;
        let z = ((hashBytes[8] | hashBytes[9] << 8 | hashBytes[10] << 16 | hashBytes[11] << 24) >>> 0) % modulo;
        const probes = [x];
        for (let i = 1; i < this.numProbes; i++) {
          x = (x + y) % modulo;
          y = (y + z) % modulo;
          probes.push(x);
        }
        return probes;
      }
      /**
       * Sets the Bloom filter bits corresponding to a given SHA-256 hash (given as hex string).
       */
      addHash(hash) {
        for (let probe of this.getProbes(hash)) {
          this.bits[probe >>> 3] |= 1 << (probe & 7);
        }
      }
      /**
       * Tests whether a given SHA-256 hash (given as hex string) is contained in the Bloom filter.
       */
      containsHash(hash) {
        if (this.numEntries === 0) return false;
        for (let probe of this.getProbes(hash)) {
          if ((this.bits[probe >>> 3] & 1 << (probe & 7)) === 0) {
            return false;
          }
        }
        return true;
      }
    };
    function encodeHashes(encoder, hashes) {
      if (!Array.isArray(hashes)) throw new TypeError("hashes must be an array");
      encoder.appendUint32(hashes.length);
      for (let i = 0; i < hashes.length; i++) {
        if (i > 0 && hashes[i - 1] >= hashes[i]) throw new RangeError("hashes must be sorted");
        const bytes = hexStringToBytes(hashes[i]);
        if (bytes.byteLength !== HASH_SIZE) throw new TypeError("heads hashes must be 256 bits");
        encoder.appendRawBytes(bytes);
      }
    }
    function decodeHashes(decoder) {
      let length = decoder.readUint32(), hashes = [];
      for (let i = 0; i < length; i++) {
        hashes.push(bytesToHexString(decoder.readRawBytes(HASH_SIZE)));
      }
      return hashes;
    }
    function encodeSyncMessage(message) {
      const encoder = new Encoder();
      encoder.appendByte(MESSAGE_TYPE_SYNC);
      encodeHashes(encoder, message.heads);
      encodeHashes(encoder, message.need);
      encoder.appendUint32(message.have.length);
      for (let have of message.have) {
        encodeHashes(encoder, have.lastSync);
        encoder.appendPrefixedBytes(have.bloom);
      }
      encoder.appendUint32(message.changes.length);
      for (let change of message.changes) {
        encoder.appendPrefixedBytes(change);
      }
      return encoder.buffer;
    }
    function decodeSyncMessage(bytes) {
      const decoder = new Decoder(bytes);
      const messageType = decoder.readByte();
      if (messageType !== MESSAGE_TYPE_SYNC) {
        throw new RangeError(`Unexpected message type: ${messageType}`);
      }
      const heads = decodeHashes(decoder);
      const need = decodeHashes(decoder);
      const haveCount = decoder.readUint32();
      let message = { heads, need, have: [], changes: [] };
      for (let i = 0; i < haveCount; i++) {
        const lastSync = decodeHashes(decoder);
        const bloom = decoder.readPrefixedBytes(decoder);
        message.have.push({ lastSync, bloom });
      }
      const changeCount = decoder.readUint32();
      for (let i = 0; i < changeCount; i++) {
        const change = decoder.readPrefixedBytes();
        message.changes.push(change);
      }
      return message;
    }
    function encodeSyncState(syncState) {
      const encoder = new Encoder();
      encoder.appendByte(PEER_STATE_TYPE);
      encodeHashes(encoder, syncState.sharedHeads);
      return encoder.buffer;
    }
    function decodeSyncState(bytes) {
      const decoder = new Decoder(bytes);
      const recordType = decoder.readByte();
      if (recordType !== PEER_STATE_TYPE) {
        throw new RangeError(`Unexpected record type: ${recordType}`);
      }
      const sharedHeads = decodeHashes(decoder);
      return Object.assign(initSyncState(), { sharedHeads });
    }
    function makeBloomFilter(backend, lastSync) {
      const newChanges = Backend.getChanges(backend, lastSync);
      const hashes = newChanges.map((change) => decodeChangeMeta(change, true).hash);
      return { lastSync, bloom: new BloomFilter(hashes).bytes };
    }
    function getChangesToSend(backend, have, need) {
      if (have.length === 0) {
        return need.map((hash) => Backend.getChangeByHash(backend, hash)).filter((change) => change !== void 0);
      }
      let lastSyncHashes = {}, bloomFilters = [];
      for (let h of have) {
        for (let hash of h.lastSync) lastSyncHashes[hash] = true;
        bloomFilters.push(new BloomFilter(h.bloom));
      }
      const changes = Backend.getChanges(backend, Object.keys(lastSyncHashes)).map((change) => decodeChangeMeta(change, true));
      let changeHashes = {}, dependents = {}, hashesToSend = {};
      for (let change of changes) {
        changeHashes[change.hash] = true;
        for (let dep of change.deps) {
          if (!dependents[dep]) dependents[dep] = [];
          dependents[dep].push(change.hash);
        }
        if (bloomFilters.every((bloom) => !bloom.containsHash(change.hash))) {
          hashesToSend[change.hash] = true;
        }
      }
      let stack = Object.keys(hashesToSend);
      while (stack.length > 0) {
        const hash = stack.pop();
        if (dependents[hash]) {
          for (let dep of dependents[hash]) {
            if (!hashesToSend[dep]) {
              hashesToSend[dep] = true;
              stack.push(dep);
            }
          }
        }
      }
      let changesToSend = [];
      for (let hash of need) {
        hashesToSend[hash] = true;
        if (!changeHashes[hash]) {
          const change = Backend.getChangeByHash(backend, hash);
          if (change) changesToSend.push(change);
        }
      }
      for (let change of changes) {
        if (hashesToSend[change.hash]) changesToSend.push(change.change);
      }
      return changesToSend;
    }
    function initSyncState() {
      return {
        sharedHeads: [],
        lastSentHeads: [],
        theirHeads: null,
        theirNeed: null,
        theirHave: null,
        sentHashes: {}
      };
    }
    function compareArrays(a, b) {
      return a.length === b.length && a.every((v, i) => v === b[i]);
    }
    function generateSyncMessage(backend, syncState) {
      if (!backend) {
        throw new Error("generateSyncMessage called with no Automerge document");
      }
      if (!syncState) {
        throw new Error("generateSyncMessage requires a syncState, which can be created with initSyncState()");
      }
      let { sharedHeads, lastSentHeads, theirHeads, theirNeed, theirHave, sentHashes } = syncState;
      const ourHeads = Backend.getHeads(backend);
      const ourNeed = Backend.getMissingDeps(backend, theirHeads || []);
      let ourHave = [];
      if (!theirHeads || ourNeed.every((hash) => theirHeads.includes(hash))) {
        ourHave = [makeBloomFilter(backend, sharedHeads)];
      }
      if (theirHave && theirHave.length > 0) {
        const lastSync = theirHave[0].lastSync;
        if (!lastSync.every((hash) => Backend.getChangeByHash(backend, hash))) {
          const resetMsg = { heads: ourHeads, need: [], have: [{ lastSync: [], bloom: new Uint8Array(0) }], changes: [] };
          return [syncState, encodeSyncMessage(resetMsg)];
        }
      }
      let changesToSend = Array.isArray(theirHave) && Array.isArray(theirNeed) ? getChangesToSend(backend, theirHave, theirNeed) : [];
      const headsUnchanged = Array.isArray(lastSentHeads) && compareArrays(ourHeads, lastSentHeads);
      const headsEqual = Array.isArray(theirHeads) && compareArrays(ourHeads, theirHeads);
      if (headsUnchanged && headsEqual && changesToSend.length === 0) {
        return [syncState, null];
      }
      changesToSend = changesToSend.filter((change) => !sentHashes[decodeChangeMeta(change, true).hash]);
      const syncMessage = { heads: ourHeads, have: ourHave, need: ourNeed, changes: changesToSend };
      if (changesToSend.length > 0) {
        sentHashes = copyObject(sentHashes);
        for (const change of changesToSend) {
          sentHashes[decodeChangeMeta(change, true).hash] = true;
        }
      }
      syncState = Object.assign({}, syncState, { lastSentHeads: ourHeads, sentHashes });
      return [syncState, encodeSyncMessage(syncMessage)];
    }
    function advanceHeads(myOldHeads, myNewHeads, ourOldSharedHeads) {
      const newHeads = myNewHeads.filter((head) => !myOldHeads.includes(head));
      const commonHeads = ourOldSharedHeads.filter((head) => myNewHeads.includes(head));
      const advancedHeads = [.../* @__PURE__ */ new Set([...newHeads, ...commonHeads])].sort();
      return advancedHeads;
    }
    function receiveSyncMessage(backend, oldSyncState, binaryMessage) {
      if (!backend) {
        throw new Error("generateSyncMessage called with no Automerge document");
      }
      if (!oldSyncState) {
        throw new Error("generateSyncMessage requires a syncState, which can be created with initSyncState()");
      }
      let { sharedHeads, lastSentHeads, sentHashes } = oldSyncState, patch = null;
      const message = decodeSyncMessage(binaryMessage);
      const beforeHeads = Backend.getHeads(backend);
      if (message.changes.length > 0) {
        [backend, patch] = Backend.applyChanges(backend, message.changes);
        sharedHeads = advanceHeads(beforeHeads, Backend.getHeads(backend), sharedHeads);
      }
      if (message.changes.length === 0 && compareArrays(message.heads, beforeHeads)) {
        lastSentHeads = message.heads;
      }
      const knownHeads = message.heads.filter((head) => Backend.getChangeByHash(backend, head));
      if (knownHeads.length === message.heads.length) {
        sharedHeads = message.heads;
        if (message.heads.length === 0) {
          lastSentHeads = [];
          sentHashes = [];
        }
      } else {
        sharedHeads = [...new Set(knownHeads.concat(sharedHeads))].sort();
      }
      const syncState = {
        sharedHeads,
        // what we have in common to generate an efficient bloom filter
        lastSentHeads,
        theirHave: message.have,
        // the information we need to calculate the changes they need
        theirHeads: message.heads,
        theirNeed: message.need,
        sentHashes
      };
      return [backend, syncState, patch];
    }
    module.exports = {
      receiveSyncMessage,
      generateSyncMessage,
      encodeSyncMessage,
      decodeSyncMessage,
      initSyncState,
      encodeSyncState,
      decodeSyncState,
      BloomFilter
      // BloomFilter is a private API, exported only for testing purposes
    };
  }
});

// node_modules/automerge/backend/index.js
var require_backend2 = __commonJS({
  "node_modules/automerge/backend/index.js"(exports, module) {
    var { init, clone, free, applyChanges, applyLocalChange, save, load, loadChanges, getPatch, getHeads, getAllChanges, getChanges, getChangesAdded, getChangeByHash, getMissingDeps } = require_backend();
    var { receiveSyncMessage, generateSyncMessage, encodeSyncMessage, decodeSyncMessage, encodeSyncState, decodeSyncState, initSyncState } = require_sync();
    module.exports = {
      init,
      clone,
      free,
      applyChanges,
      applyLocalChange,
      save,
      load,
      loadChanges,
      getPatch,
      getHeads,
      getAllChanges,
      getChanges,
      getChangesAdded,
      getChangeByHash,
      getMissingDeps,
      receiveSyncMessage,
      generateSyncMessage,
      encodeSyncMessage,
      decodeSyncMessage,
      encodeSyncState,
      decodeSyncState,
      initSyncState
    };
  }
});

// node_modules/automerge/src/automerge.js
var require_automerge = __commonJS({
  "node_modules/automerge/src/automerge.js"(exports, module) {
    var uuid = require_uuid2();
    var Frontend = require_frontend();
    var { OPTIONS } = require_constants();
    var { encodeChange, decodeChange } = require_columnar();
    var { isObject } = require_common();
    var backend = require_backend2();
    function init(options) {
      if (typeof options === "string") {
        options = { actorId: options };
      } else if (typeof options === "undefined") {
        options = {};
      } else if (!isObject(options)) {
        throw new TypeError(`Unsupported options for init(): ${options}`);
      }
      return Frontend.init(Object.assign({ backend }, options));
    }
    function from(initialState, options) {
      const changeOpts = { message: "Initialization" };
      return change(init(options), changeOpts, (doc) => Object.assign(doc, initialState));
    }
    function change(doc, options, callback) {
      const [newDoc] = Frontend.change(doc, options, callback);
      return newDoc;
    }
    function emptyChange(doc, options) {
      const [newDoc] = Frontend.emptyChange(doc, options);
      return newDoc;
    }
    function clone(doc, options = {}) {
      const state = backend.clone(Frontend.getBackendState(doc, "clone"));
      return applyPatch(init(options), backend.getPatch(state), state, [], options);
    }
    function free(doc) {
      backend.free(Frontend.getBackendState(doc, "free"));
    }
    function load(data, options = {}) {
      const state = backend.load(data);
      return applyPatch(init(options), backend.getPatch(state), state, [data], options);
    }
    function save(doc) {
      return backend.save(Frontend.getBackendState(doc, "save"));
    }
    function merge(localDoc, remoteDoc) {
      const localState = Frontend.getBackendState(localDoc, "merge");
      const remoteState = Frontend.getBackendState(remoteDoc, "merge", "second");
      const changes = backend.getChangesAdded(localState, remoteState);
      const [updatedDoc] = applyChanges(localDoc, changes);
      return updatedDoc;
    }
    function getChanges(oldDoc, newDoc) {
      const oldState = Frontend.getBackendState(oldDoc, "getChanges");
      const newState = Frontend.getBackendState(newDoc, "getChanges", "second");
      return backend.getChanges(newState, backend.getHeads(oldState));
    }
    function getAllChanges(doc) {
      return backend.getAllChanges(Frontend.getBackendState(doc, "getAllChanges"));
    }
    function applyPatch(doc, patch, backendState, changes, options) {
      const newDoc = Frontend.applyPatch(doc, patch, backendState);
      const patchCallback = options.patchCallback || doc[OPTIONS].patchCallback;
      if (patchCallback) {
        patchCallback(patch, doc, newDoc, false, changes);
      }
      return newDoc;
    }
    function applyChanges(doc, changes, options = {}) {
      const oldState = Frontend.getBackendState(doc, "applyChanges");
      const [newState, patch] = backend.applyChanges(oldState, changes);
      return [applyPatch(doc, patch, newState, changes, options), patch];
    }
    function equals(val1, val2) {
      if (!isObject(val1) || !isObject(val2)) return val1 === val2;
      const keys1 = Object.keys(val1).sort(), keys2 = Object.keys(val2).sort();
      if (keys1.length !== keys2.length) return false;
      for (let i = 0; i < keys1.length; i++) {
        if (keys1[i] !== keys2[i]) return false;
        if (!equals(val1[keys1[i]], val2[keys2[i]])) return false;
      }
      return true;
    }
    function getHistory(doc) {
      const actor = Frontend.getActorId(doc);
      const history = getAllChanges(doc);
      return history.map(
        (change2, index) => ({
          get change() {
            return decodeChange(change2);
          },
          get snapshot() {
            const state = backend.loadChanges(backend.init(), history.slice(0, index + 1));
            return Frontend.applyPatch(init(actor), backend.getPatch(state), state);
          }
        })
      );
    }
    function generateSyncMessage(doc, syncState) {
      const state = Frontend.getBackendState(doc, "generateSyncMessage");
      return backend.generateSyncMessage(state, syncState);
    }
    function receiveSyncMessage(doc, oldSyncState, message) {
      const oldBackendState = Frontend.getBackendState(doc, "receiveSyncMessage");
      const [backendState, syncState, patch] = backend.receiveSyncMessage(oldBackendState, oldSyncState, message);
      if (!patch) return [doc, syncState, patch];
      let changes = null;
      if (doc[OPTIONS].patchCallback) {
        changes = backend.decodeSyncMessage(message).changes;
      }
      return [applyPatch(doc, patch, backendState, changes, {}), syncState, patch];
    }
    function initSyncState() {
      return backend.initSyncState();
    }
    function setDefaultBackend(newBackend) {
      backend = newBackend;
    }
    module.exports = {
      init,
      from,
      change,
      emptyChange,
      clone,
      free,
      load,
      save,
      merge,
      getChanges,
      getAllChanges,
      applyChanges,
      encodeChange,
      decodeChange,
      equals,
      getHistory,
      uuid,
      Frontend,
      setDefaultBackend,
      generateSyncMessage,
      receiveSyncMessage,
      initSyncState,
      get Backend() {
        return backend;
      }
    };
    for (let name of [
      "getObjectId",
      "getObjectById",
      "getActorId",
      "setActorId",
      "getConflicts",
      "getLastLocalChange",
      "Text",
      "Table",
      "Counter",
      "Observable",
      "Int",
      "Uint",
      "Float64"
    ]) {
      module.exports[name] = Frontend[name];
    }
  }
});
export default require_automerge();
//# sourceMappingURL=automerge.js.map
